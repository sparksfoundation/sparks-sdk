{"version":3,"sources":["../../../src/ciphers/X25519SalsaPolyPassword/index.ts","../../../src/ciphers/X25519SalsaPoly/index.ts","../../../src/utilities/index.ts","../../../src/events/SparkEvent/index.ts","../../../src/errors/ciphers.ts","../../../src/ciphers/SparkCipher/index.ts"],"sourcesContent":["import util from \"tweetnacl-util\";\nimport { DecryptedData, EncryptedData, CipherKeyPair, CipherPublicKey, CipherSecretKey } from '../SparkCipher/types';\nimport { X25519SalsaPoly } from \"../X25519SalsaPoly\";\nimport nacl from \"tweetnacl\";\nimport * as scrypt from \"scrypt-pbkdf\";\nimport { SparkCipher } from \"../SparkCipher\";\nimport { SparkErrors } from \"../../errors\";\nimport { CipherErrors } from \"../../errors/ciphers\";\nimport { SparkEvent } from \"../../events/SparkEvent\";\n\nexport type CipherKeyPairWithSalt = CipherKeyPair & { salt: string };\n\nexport class X25519SalsaPolyPassword extends SparkCipher {\n  private _X25519SalsaPoly: X25519SalsaPoly;\n  private _salt: string;\n  \n  constructor() {\n    super({\n      algorithm: 'x25519-salsa20-poly1305',\n    });\n    this._X25519SalsaPoly = new X25519SalsaPoly();\n  }\n\n  public get salt(): string {\n    return this._salt;\n  }\n\n  public get publicKey(): CipherPublicKey {\n    return this._X25519SalsaPoly.publicKey;\n  }\n\n  public get secretKey(): CipherSecretKey {\n    return this._X25519SalsaPoly.secretKey;\n  }\n\n  public get keyPair(): CipherKeyPairWithSalt {\n    const keyPair = this._X25519SalsaPoly.keyPair;\n    return { ...keyPair, salt: this._salt };\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    if (data?.salt) this._salt = data.salt;\n    await super.import(data);\n    return Promise.resolve();\n  }\n\n  public async export(): Promise<Record<string, any>> {\n    const data = await super.export();\n    data.salt = this._salt;\n    return Promise.resolve(data);\n  }\n\n  public async generateSharedKey(params: Parameters<X25519SalsaPoly['generateSharedKey']>[0]): Promise<string> {\n    const sharedKey = await this._X25519SalsaPoly.generateSharedKey(params);\n    if (!sharedKey) throw CipherErrors.CIPHER_SHARED_KEY_ERROR();\n    return sharedKey;\n  }\n\n  public async generateKeyPair({ password, salt: nonce }: { password: string, salt?: string }): Promise<CipherKeyPairWithSalt> {\n    try {\n      const options = { N: 16384, r: 8, p: 1 };\n      const salt = nonce || util.encodeBase64(nacl.randomBytes(16));\n      const len = nacl.box.secretKeyLength / 2;\n      const buffer = await scrypt.scrypt(password, salt, len, options);\n\n      const seed = [...new Uint8Array(buffer)]\n        .map((x) => x.toString(16).padStart(2, '0'))\n        .join('');\n\n      const uint8Seed = util.decodeUTF8(seed);\n      const keyPair = nacl.box.keyPair.fromSecretKey(uint8Seed);\n      const secretKey = util.encodeBase64(keyPair.secretKey);\n      const publicKey = util.encodeBase64(keyPair.publicKey);\n\n      if (!secretKey || !publicKey || !salt) {\n        throw CipherErrors.CIPHER_KEYPAIR_ERROR();\n      }\n\n      return { publicKey, secretKey, salt } as CipherKeyPairWithSalt;\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(CipherErrors.CIPHER_UNEXPECTED_ERROR({\n        message: `Failed to generate key pair. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public setKeyPair({ publicKey, secretKey, salt }: CipherKeyPairWithSalt): void {\n    this._salt = salt;\n    if (!salt) throw CipherErrors.CIPHER_KEYPAIR_ERROR();\n    this._X25519SalsaPoly.setKeyPair({ publicKey, secretKey });\n  }\n\n  public async decrypt(params: Parameters<X25519SalsaPoly['decrypt']>[0]): Promise<DecryptedData> {\n    return this._X25519SalsaPoly.decrypt(params);\n  }\n\n  public async encrypt(params: Parameters<X25519SalsaPoly['encrypt']>[0]): Promise<EncryptedData> {\n    return this._X25519SalsaPoly.encrypt(params);\n  }\n}\n","import nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { parseJSON } from \"../../utilities\";\nimport { DecryptedData, EncryptedData, CipherKeyPair, CipherPublicKey, EncryptionSecret, EncryptionSharedKey } from '../SparkCipher/types';\nimport { SparkCipher } from \"../SparkCipher\";\nimport { SparkErrors } from \"../../errors\";\nimport { CipherErrors } from \"../../errors/ciphers\";\nimport { SparkEvent } from \"../../events/SparkEvent\";\n\nexport class X25519SalsaPoly extends SparkCipher {\n  constructor() {\n    super({\n      algorithm: 'x25519-salsa20-poly1305',\n    });\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    await super.import(data);\n    return Promise.resolve();\n  }\n\n  public async export(): Promise<Record<string, any>> {\n    const data = await super.export() || {};\n    return Promise.resolve(data);\n  }\n\n  public async generateKeyPair(params?: { secretKey?: EncryptionSecret }): ReturnType<SparkCipher['generateKeyPair']> {\n    try {\n      const keyPair = params?.secretKey ? nacl.box.keyPair.fromSecretKey(util.decodeBase64(params?.secretKey)) : nacl.box.keyPair();\n      if (!keyPair) throw CipherErrors.CIPHER_KEYPAIR_ERROR();\n      const publicKey = util.encodeBase64(keyPair.publicKey);\n      const secretKey = util.encodeBase64(keyPair.secretKey);\n      if (!publicKey || !secretKey) throw CipherErrors.CIPHER_KEYPAIR_ERROR();\n      return Promise.resolve({ publicKey, secretKey } as CipherKeyPair);\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(CipherErrors.CIPHER_UNEXPECTED_ERROR({\n        message: `Failed to generate key pair. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async generateSharedKey({ publicKey }: { publicKey: CipherPublicKey }): ReturnType<SparkCipher['generateSharedKey']> {\n    try {\n      const baseCipherPublicKey = util.decodeBase64(publicKey);\n      const baseCipherSecretKey = util.decodeBase64(this.secretKey);\n      const uintSharedKey = nacl.box.before(baseCipherPublicKey, baseCipherSecretKey);\n      const baseSharedKey = util.encodeBase64(uintSharedKey);\n      if (!baseSharedKey) throw CipherErrors.CIPHER_KEYPAIR_ERROR();\n      return Promise.resolve(baseSharedKey as EncryptionSharedKey);\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(CipherErrors.CIPHER_UNEXPECTED_ERROR({\n        message: `Failed to generate shared key. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async encrypt({ data, publicKey, sharedKey }: { data: DecryptedData, publicKey?: CipherPublicKey, sharedKey?: EncryptionSharedKey }): ReturnType<SparkCipher['encrypt']> {\n    try {\n      let box;\n      const utfData = typeof data === 'string' ? data : JSON.stringify(data);\n      const uintData = util.decodeUTF8(utfData);\n      const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n      if (typeof publicKey === 'string') {\n        const publicKeyUint = util.decodeBase64(publicKey);\n        box = nacl.box(uintData, nonce, publicKeyUint, util.decodeBase64(this.secretKey));\n      } else if (typeof sharedKey === 'string') {\n        const sharedKeyUint = util.decodeBase64(sharedKey);\n        box = nacl.box.after(uintData, nonce, sharedKeyUint);\n      } else {\n        const secreKeyUint = util.decodeBase64(this.secretKey);\n        box = nacl.secretbox(uintData, nonce, secreKeyUint);\n      }\n\n      const encrypted = new Uint8Array(nonce.length + box.length);\n      if (!encrypted) throw CipherErrors.CIPHER_ENCRYPTION_ERROR();\n\n      encrypted.set(nonce);\n      encrypted.set(box, nonce.length);\n      const ciphertext = util.encodeBase64(encrypted);\n      if (!ciphertext) throw CipherErrors.CIPHER_ENCRYPTION_ERROR();\n      return Promise.resolve(ciphertext as EncryptedData);\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(CipherErrors.CIPHER_UNEXPECTED_ERROR({\n        message: `Failed to encrypt data. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async decrypt({ data, publicKey, sharedKey }: { data: EncryptedData, publicKey?: CipherPublicKey, sharedKey?: EncryptionSharedKey }): ReturnType<SparkCipher['decrypt']> {\n    try {\n      const uintDataAndNonce = util.decodeBase64(data);\n      const nonce = uintDataAndNonce.slice(0, nacl.secretbox.nonceLength);\n      const uintData = uintDataAndNonce.slice(nacl.secretbox.nonceLength, uintDataAndNonce.length);\n\n      let decrypted;\n      if (typeof publicKey === 'string') {\n        const publicKeyUint = util.decodeBase64(publicKey);\n        decrypted = nacl.box.open(uintData, nonce, publicKeyUint, util.decodeBase64(this.secretKey));\n      } else if (typeof sharedKey === 'string') {\n        const sharedKeyUint = util.decodeBase64(sharedKey);\n        decrypted = nacl.box.open.after(uintData, nonce, sharedKeyUint);\n      } else {\n        const secreKeyUint = util.decodeBase64(this.secretKey);\n        decrypted = nacl.secretbox.open(uintData, nonce, secreKeyUint);\n      }\n\n      if (!(decrypted instanceof Uint8Array)) {\n        throw CipherErrors.CIPHER_DECRYPTION_ERROR();\n      }\n\n      const utf8Result = util.encodeUTF8(decrypted);\n      const parsed = parseJSON(utf8Result) || utf8Result;\n      if (!parsed || !utf8Result) throw CipherErrors.CIPHER_DECRYPTION_ERROR();\n      return Promise.resolve(parsed as DecryptedData);\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(CipherErrors.CIPHER_UNEXPECTED_ERROR({\n        message: `Failed to decrypt data. ${error?.message || ''}`,\n      }));\n    }\n  }\n}","import nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { createId, isCuid } from '@paralleldrive/cuid2';\n\n/**\n * @returns a timestamp in milliseconds since epoch in terms of UTC\n */\nexport function utcEpochTimestamp() {\n  const now = new Date()\n  return now.getTime() + now.getTimezoneOffset() * 60 * 1000;\n}\n\n/**\n * @returns a parsed json string or null if it fails\n */\nexport function parseJSON(data: string) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n}\n\n/**\n * @returns a new unique salt\n */\nexport function randomSalt(len: number = 32) {\n  return util.encodeBase64(nacl.randomBytes(len));\n}\n\n/**\n * @returns a new unique identifier\n */\nexport function randomCuid() {\n  return createId();\n}\n\n/**\n * @returns whether the identifier is a valid CUID\n */\nexport function validCuid(id: string) {\n  return isCuid(id);\n}\n\n/**\n * SNAKE_CASE to PascalCase\n * @returns a PascalCase string\n */\nexport function snakeToPascal(str: string) {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, char) => char.toUpperCase()).replace(/^[a-z]/, char => char.toUpperCase());\n}","import { randomCuid, utcEpochTimestamp } from \"../../utilities\";\nimport { ConfirmEventType, CreateEventFunction, CreateEventParams, ErrorEventType, RequestEventType, SparkEventInterface, SparkEventParams } from \"./types\";\n\n\nexport class SparkEvent implements SparkEventInterface {\n  readonly type:  RequestEventType | ConfirmEventType | ErrorEventType;\n  readonly timestamp: number;\n  readonly metadata: Record<string, any>;\n  readonly data: Record<string, any>;\n  readonly digest: string;\n\n  constructor(args: SparkEventParams) {\n    this.type = args.type;\n    this.metadata = args.metadata;\n    this.timestamp = args.timestamp;\n    if (args.data) this.data = args.data;\n    if (args.digest) this.digest = args.digest;\n  }\n}\n\nexport class SparkRequestEvent extends SparkEvent {\n  declare readonly type: RequestEventType;\n}\nexport class SparkConfirmEvent extends SparkEvent {\n  declare readonly type: ConfirmEventType;\n}\nexport class SparkErrorEvent extends SparkEvent {\n  declare readonly type: ErrorEventType;\n}\n\nexport const createEvent: CreateEventFunction = (params: CreateEventParams): any => {\n  const { type, data, digest } = params;\n  const timestamp: number = utcEpochTimestamp();\n  const metadata = { ...(params.metadata || {}), eventId: randomCuid() };\n\n  const invalidEvent = (!type.endsWith(\"_REQUEST\") && !type.endsWith(\"_CONFIRM\") && !type.endsWith(\"_ERROR\"));\n  const invalidParams = !!((data && digest) || (!data && !digest));\n\n  let event;\n  if (!!data) event = new SparkEvent({ type, metadata, timestamp, data });\n  else if (!!digest) event = new SparkEvent({ type, metadata, timestamp, digest });\n  else event = null;\n\n  if (invalidEvent || invalidParams || !event) {\n    throw new SparkEvent({\n      type: 'CREATE_EVENT_ERROR',\n      metadata: {\n        eventId: randomCuid()\n      },\n      timestamp,\n      data: { message: invalidEvent ? `Invalid event type: ${type}` : `Invalid event params: ${JSON.stringify(params)}` },\n    });\n  }\n\n  // TODO - settings for optional logging\n  const isError = event.type.endsWith(\"_ERROR\");\n  // if (isError) console.error(event);\n\n  return event;\n};\n","import { createEvent } from \"../events/SparkEvent\";\n\nexport const CipherErrorTypes = {\n  CIPHER_PUBLICKEY_ERROR: 'CIPHER_PUBLICKEY_ERROR',\n  CIPHER_SECRETKEY_ERROR: 'CIPHER_SECRETKEY_ERROR',\n  CIPHER_KEYPAIR_ERROR: 'CIPHER_KEYPAIR_ERROR',\n  CIPHER_ENCRYPTION_ERROR: 'CIPHER_ENCRYPTION_ERROR',\n  CIPHER_DECRYPTION_ERROR: 'CIPHER_DECRYPTION_ERROR',\n  CIPHER_SHARED_KEY_ERROR: 'CIPHER_SHARED_KEY_ERROR',\n  CIPHER_UNEXPECTED_ERROR: 'CIPHER_UNEXPECTED_ERROR',\n} as const;\n\nexport const CipherErrors = {\n  CIPHER_PUBLICKEY_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_PUBLICKEY_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate public key.' }\n  }),\n  CIPHER_SECRETKEY_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_SECRETKEY_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate secret key.' }\n  }),\n  CIPHER_KEYPAIR_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_KEYPAIR_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate key pair.' }\n  }),\n  CIPHER_ENCRYPTION_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_ENCRYPTION_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to encrypt data.' }\n  }),\n  CIPHER_DECRYPTION_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_DECRYPTION_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to decrypt data.' }\n  }),\n  CIPHER_SHARED_KEY_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_SHARED_KEY_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate shared key.' }\n  }),\n  CIPHER_UNEXPECTED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: CipherErrorTypes.CIPHER_UNEXPECTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected cipher error.' }\n  }),\n}\n\n","import { SparkErrors } from \"../../errors\";\nimport { CipherErrors } from \"../../errors/ciphers\";\nimport { CipherKeyPair, CipherPublicKey, CipherSecretKey, DecryptedData, EncryptedData, EncryptionSharedKey, SparkCipherInterface } from \"./types\";\n\nexport abstract class SparkCipher implements SparkCipherInterface {\n  public readonly algorithm: string;\n\n  private _publicKey: string;\n  private _secretKey: string;\n\n  constructor({ algorithm }: { algorithm: string}) {\n    this.algorithm = algorithm;\n    this.setKeyPair = this.setKeyPair.bind(this);\n    this.generateKeyPair = this.generateKeyPair.bind(this);\n    this.generateSharedKey = this.generateSharedKey.bind(this);\n    this.encrypt = this.encrypt.bind(this);\n    this.decrypt = this.decrypt.bind(this);\n  }\n\n  public get publicKey(): CipherPublicKey {\n    return this._publicKey;\n  }\n\n  public get secretKey(): CipherSecretKey {\n    return this._secretKey;\n  }\n\n  public get keyPair(): CipherKeyPair {\n    const publicKey = this.publicKey;\n    const secretKey = this.secretKey;\n    return { publicKey, secretKey };\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    return Promise.resolve();\n  }\n\n  public async export(): Promise<Record<string, any>> {\n    return Promise.resolve({});\n  }\n\n  public setKeyPair({ publicKey, secretKey }: CipherKeyPair): void {\n    if (!publicKey) throw CipherErrors.CIPHER_PUBLICKEY_ERROR();\n    if (!secretKey) throw CipherErrors.CIPHER_SECRETKEY_ERROR();\n    this._publicKey = publicKey;\n    this._secretKey = secretKey;\n  }\n\n  public abstract generateKeyPair(params?: Record<string, any>): Promise<CipherKeyPair>;\n  public abstract generateSharedKey(params?: Record<string, any>): Promise<EncryptionSharedKey>;\n  public abstract encrypt(params?: Record<string, any>): Promise<EncryptedData>;\n  public abstract decrypt(params?: Record<string, any>): Promise<DecryptedData>;\n}\n"],"mappings":";AAAA,OAAOA,WAAU;;;ACAjB,OAAOC,WAAU;AACjB,OAAOC,WAAU;;;ACDjB,OAAO,UAAU;AACjB,OAAO,UAAU;AACjB,SAAS,UAAU,cAAc;AAK1B,SAAS,oBAAoB;AAClC,QAAM,MAAM,oBAAI,KAAK;AACrB,SAAO,IAAI,QAAQ,IAAI,IAAI,kBAAkB,IAAI,KAAK;AACxD;AAKO,SAAS,UAAU,MAAc;AACtC,MAAI;AACF,WAAO,KAAK,MAAM,IAAI;AAAA,EACxB,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAYO,SAAS,aAAa;AAC3B,SAAO,SAAS;AAClB;;;AC/BO,IAAM,aAAN,MAAgD;AAAA,EAC5C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAET,YAAY,MAAwB;AAClC,SAAK,OAAO,KAAK;AACjB,SAAK,WAAW,KAAK;AACrB,SAAK,YAAY,KAAK;AACtB,QAAI,KAAK;AAAM,WAAK,OAAO,KAAK;AAChC,QAAI,KAAK;AAAQ,WAAK,SAAS,KAAK;AAAA,EACtC;AACF;AAYO,IAAM,cAAmC,CAAC,WAAmC;AAClF,QAAM,EAAE,MAAM,MAAM,OAAO,IAAI;AAC/B,QAAM,YAAoB,kBAAkB;AAC5C,QAAM,WAAW,EAAE,GAAI,OAAO,YAAY,CAAC,GAAI,SAAS,WAAW,EAAE;AAErE,QAAM,eAAgB,CAAC,KAAK,SAAS,UAAU,KAAK,CAAC,KAAK,SAAS,UAAU,KAAK,CAAC,KAAK,SAAS,QAAQ;AACzG,QAAM,gBAAgB,CAAC,EAAG,QAAQ,UAAY,CAAC,QAAQ,CAAC;AAExD,MAAI;AACJ,MAAI,CAAC,CAAC;AAAM,YAAQ,IAAI,WAAW,EAAE,MAAM,UAAU,WAAW,KAAK,CAAC;AAAA,WAC7D,CAAC,CAAC;AAAQ,YAAQ,IAAI,WAAW,EAAE,MAAM,UAAU,WAAW,OAAO,CAAC;AAAA;AAC1E,YAAQ;AAEb,MAAI,gBAAgB,iBAAiB,CAAC,OAAO;AAC3C,UAAM,IAAI,WAAW;AAAA,MACnB,MAAM;AAAA,MACN,UAAU;AAAA,QACR,SAAS,WAAW;AAAA,MACtB;AAAA,MACA;AAAA,MACA,MAAM,EAAE,SAAS,eAAe,uBAAuB,IAAI,KAAK,yBAAyB,KAAK,UAAU,MAAM,CAAC,GAAG;AAAA,IACpH,CAAC;AAAA,EACH;AAGA,QAAM,UAAU,MAAM,KAAK,SAAS,QAAQ;AAG5C,SAAO;AACT;;;ACzDO,IAAM,mBAAmB;AAAA,EAC9B,wBAAwB;AAAA,EACxB,wBAAwB;AAAA,EACxB,sBAAsB;AAAA,EACtB,yBAAyB;AAAA,EACzB,yBAAyB;AAAA,EACzB,yBAAyB;AAAA,EACzB,yBAAyB;AAC3B;AAEO,IAAM,eAAe;AAAA,EAC1B,wBAAwB,CAAC,EAAE,WAAW,CAAC,EAAE,IAAwC,CAAC,MAAM,YAAY;AAAA,IAClG,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,iCAAiC;AAAA,EACpD,CAAC;AAAA,EACD,wBAAwB,CAAC,EAAE,WAAW,CAAC,EAAE,IAAwC,CAAC,MAAM,YAAY;AAAA,IAClG,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,iCAAiC;AAAA,EACpD,CAAC;AAAA,EACD,sBAAsB,CAAC,EAAE,WAAW,CAAC,EAAE,IAAwC,CAAC,MAAM,YAAY;AAAA,IAChG,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,+BAA+B;AAAA,EAClD,CAAC;AAAA,EACD,yBAAyB,CAAC,EAAE,WAAW,CAAC,EAAE,IAAwC,CAAC,MAAM,YAAY;AAAA,IACnG,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,0BAA0B;AAAA,EAC7C,CAAC;AAAA,EACD,yBAAyB,CAAC,EAAE,WAAW,CAAC,EAAE,IAAwC,CAAC,MAAM,YAAY;AAAA,IACnG,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,0BAA0B;AAAA,EAC7C,CAAC;AAAA,EACD,yBAAyB,CAAC,EAAE,WAAW,CAAC,EAAE,IAAwC,CAAC,MAAM,YAAY;AAAA,IACnG,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,iCAAiC;AAAA,EACpD,CAAC;AAAA,EACD,yBAAyB,CAAC,EAAE,WAAW,CAAC,GAAG,QAAQ,IAA0D,CAAC,MAAM,YAAY;AAAA,IAC9H,MAAM,iBAAiB;AAAA,IACvB,UAAU,EAAE,GAAG,SAAS;AAAA,IACxB,MAAM,EAAE,SAAS,WAAW,2BAA2B;AAAA,EACzD,CAAC;AACH;;;AC5CO,IAAe,cAAf,MAA2D;AAAA,EAChD;AAAA,EAER;AAAA,EACA;AAAA,EAER,YAAY,EAAE,UAAU,GAAyB;AAC/C,SAAK,YAAY;AACjB,SAAK,aAAa,KAAK,WAAW,KAAK,IAAI;AAC3C,SAAK,kBAAkB,KAAK,gBAAgB,KAAK,IAAI;AACrD,SAAK,oBAAoB,KAAK,kBAAkB,KAAK,IAAI;AACzD,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;AACrC,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;AAAA,EACvC;AAAA,EAEA,IAAW,YAA6B;AACtC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,YAA6B;AACtC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,UAAyB;AAClC,UAAM,YAAY,KAAK;AACvB,UAAM,YAAY,KAAK;AACvB,WAAO,EAAE,WAAW,UAAU;AAAA,EAChC;AAAA,EAEA,MAAa,OAAO,MAA0C;AAC5D,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEA,MAAa,SAAuC;AAClD,WAAO,QAAQ,QAAQ,CAAC,CAAC;AAAA,EAC3B;AAAA,EAEO,WAAW,EAAE,WAAW,UAAU,GAAwB;AAC/D,QAAI,CAAC;AAAW,YAAM,aAAa,uBAAuB;AAC1D,QAAI,CAAC;AAAW,YAAM,aAAa,uBAAuB;AAC1D,SAAK,aAAa;AAClB,SAAK,aAAa;AAAA,EACpB;AAMF;;;AJ3CO,IAAM,kBAAN,cAA8B,YAAY;AAAA,EAC/C,cAAc;AACZ,UAAM;AAAA,MACJ,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAAA,EAEA,MAAa,OAAO,MAA0C;AAC5D,UAAM,MAAM,OAAO,IAAI;AACvB,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEA,MAAa,SAAuC;AAClD,UAAM,OAAO,MAAM,MAAM,OAAO,KAAK,CAAC;AACtC,WAAO,QAAQ,QAAQ,IAAI;AAAA,EAC7B;AAAA,EAEA,MAAa,gBAAgB,QAAuF;AAClH,QAAI;AACF,YAAM,UAAU,QAAQ,YAAYC,MAAK,IAAI,QAAQ,cAAcC,MAAK,aAAa,QAAQ,SAAS,CAAC,IAAID,MAAK,IAAI,QAAQ;AAC5H,UAAI,CAAC;AAAS,cAAM,aAAa,qBAAqB;AACtD,YAAM,YAAYC,MAAK,aAAa,QAAQ,SAAS;AACrD,YAAM,YAAYA,MAAK,aAAa,QAAQ,SAAS;AACrD,UAAI,CAAC,aAAa,CAAC;AAAW,cAAM,aAAa,qBAAqB;AACtE,aAAO,QAAQ,QAAQ,EAAE,WAAW,UAAU,CAAkB;AAAA,IAClE,SAAS,OAAY;AACnB,UAAI,iBAAiB;AAAY,eAAO,QAAQ,OAAO,KAAK;AAC5D,aAAO,QAAQ,OAAO,aAAa,wBAAwB;AAAA,QACzD,SAAS,gCAAgC,OAAO,WAAW,EAAE;AAAA,MAC/D,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,MAAa,kBAAkB,EAAE,UAAU,GAAiF;AAC1H,QAAI;AACF,YAAM,sBAAsBA,MAAK,aAAa,SAAS;AACvD,YAAM,sBAAsBA,MAAK,aAAa,KAAK,SAAS;AAC5D,YAAM,gBAAgBD,MAAK,IAAI,OAAO,qBAAqB,mBAAmB;AAC9E,YAAM,gBAAgBC,MAAK,aAAa,aAAa;AACrD,UAAI,CAAC;AAAe,cAAM,aAAa,qBAAqB;AAC5D,aAAO,QAAQ,QAAQ,aAAoC;AAAA,IAC7D,SAAS,OAAY;AACnB,UAAI,iBAAiB;AAAY,eAAO,QAAQ,OAAO,KAAK;AAC5D,aAAO,QAAQ,OAAO,aAAa,wBAAwB;AAAA,QACzD,SAAS,kCAAkC,OAAO,WAAW,EAAE;AAAA,MACjE,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,MAAa,QAAQ,EAAE,MAAM,WAAW,UAAU,GAA8H;AAC9K,QAAI;AACF,UAAI;AACJ,YAAM,UAAU,OAAO,SAAS,WAAW,OAAO,KAAK,UAAU,IAAI;AACrE,YAAM,WAAWA,MAAK,WAAW,OAAO;AACxC,YAAM,QAAQD,MAAK,YAAYA,MAAK,IAAI,WAAW;AAEnD,UAAI,OAAO,cAAc,UAAU;AACjC,cAAM,gBAAgBC,MAAK,aAAa,SAAS;AACjD,cAAMD,MAAK,IAAI,UAAU,OAAO,eAAeC,MAAK,aAAa,KAAK,SAAS,CAAC;AAAA,MAClF,WAAW,OAAO,cAAc,UAAU;AACxC,cAAM,gBAAgBA,MAAK,aAAa,SAAS;AACjD,cAAMD,MAAK,IAAI,MAAM,UAAU,OAAO,aAAa;AAAA,MACrD,OAAO;AACL,cAAM,eAAeC,MAAK,aAAa,KAAK,SAAS;AACrD,cAAMD,MAAK,UAAU,UAAU,OAAO,YAAY;AAAA,MACpD;AAEA,YAAM,YAAY,IAAI,WAAW,MAAM,SAAS,IAAI,MAAM;AAC1D,UAAI,CAAC;AAAW,cAAM,aAAa,wBAAwB;AAE3D,gBAAU,IAAI,KAAK;AACnB,gBAAU,IAAI,KAAK,MAAM,MAAM;AAC/B,YAAM,aAAaC,MAAK,aAAa,SAAS;AAC9C,UAAI,CAAC;AAAY,cAAM,aAAa,wBAAwB;AAC5D,aAAO,QAAQ,QAAQ,UAA2B;AAAA,IACpD,SAAS,OAAY;AACnB,UAAI,iBAAiB;AAAY,eAAO,QAAQ,OAAO,KAAK;AAC5D,aAAO,QAAQ,OAAO,aAAa,wBAAwB;AAAA,QACzD,SAAS,2BAA2B,OAAO,WAAW,EAAE;AAAA,MAC1D,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,MAAa,QAAQ,EAAE,MAAM,WAAW,UAAU,GAA8H;AAC9K,QAAI;AACF,YAAM,mBAAmBA,MAAK,aAAa,IAAI;AAC/C,YAAM,QAAQ,iBAAiB,MAAM,GAAGD,MAAK,UAAU,WAAW;AAClE,YAAM,WAAW,iBAAiB,MAAMA,MAAK,UAAU,aAAa,iBAAiB,MAAM;AAE3F,UAAI;AACJ,UAAI,OAAO,cAAc,UAAU;AACjC,cAAM,gBAAgBC,MAAK,aAAa,SAAS;AACjD,oBAAYD,MAAK,IAAI,KAAK,UAAU,OAAO,eAAeC,MAAK,aAAa,KAAK,SAAS,CAAC;AAAA,MAC7F,WAAW,OAAO,cAAc,UAAU;AACxC,cAAM,gBAAgBA,MAAK,aAAa,SAAS;AACjD,oBAAYD,MAAK,IAAI,KAAK,MAAM,UAAU,OAAO,aAAa;AAAA,MAChE,OAAO;AACL,cAAM,eAAeC,MAAK,aAAa,KAAK,SAAS;AACrD,oBAAYD,MAAK,UAAU,KAAK,UAAU,OAAO,YAAY;AAAA,MAC/D;AAEA,UAAI,EAAE,qBAAqB,aAAa;AACtC,cAAM,aAAa,wBAAwB;AAAA,MAC7C;AAEA,YAAM,aAAaC,MAAK,WAAW,SAAS;AAC5C,YAAM,SAAS,UAAU,UAAU,KAAK;AACxC,UAAI,CAAC,UAAU,CAAC;AAAY,cAAM,aAAa,wBAAwB;AACvE,aAAO,QAAQ,QAAQ,MAAuB;AAAA,IAChD,SAAS,OAAY;AACnB,UAAI,iBAAiB;AAAY,eAAO,QAAQ,OAAO,KAAK;AAC5D,aAAO,QAAQ,OAAO,aAAa,wBAAwB;AAAA,QACzD,SAAS,2BAA2B,OAAO,WAAW,EAAE;AAAA,MAC1D,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AACF;;;AD1HA,OAAOC,WAAU;AACjB,YAAY,YAAY;AAQjB,IAAM,0BAAN,cAAsC,YAAY;AAAA,EAC/C;AAAA,EACA;AAAA,EAER,cAAc;AACZ,UAAM;AAAA,MACJ,WAAW;AAAA,IACb,CAAC;AACD,SAAK,mBAAmB,IAAI,gBAAgB;AAAA,EAC9C;AAAA,EAEA,IAAW,OAAe;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,YAA6B;AACtC,WAAO,KAAK,iBAAiB;AAAA,EAC/B;AAAA,EAEA,IAAW,YAA6B;AACtC,WAAO,KAAK,iBAAiB;AAAA,EAC/B;AAAA,EAEA,IAAW,UAAiC;AAC1C,UAAM,UAAU,KAAK,iBAAiB;AACtC,WAAO,EAAE,GAAG,SAAS,MAAM,KAAK,MAAM;AAAA,EACxC;AAAA,EAEA,MAAa,OAAO,MAA0C;AAC5D,QAAI,MAAM;AAAM,WAAK,QAAQ,KAAK;AAClC,UAAM,MAAM,OAAO,IAAI;AACvB,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEA,MAAa,SAAuC;AAClD,UAAM,OAAO,MAAM,MAAM,OAAO;AAChC,SAAK,OAAO,KAAK;AACjB,WAAO,QAAQ,QAAQ,IAAI;AAAA,EAC7B;AAAA,EAEA,MAAa,kBAAkB,QAA8E;AAC3G,UAAM,YAAY,MAAM,KAAK,iBAAiB,kBAAkB,MAAM;AACtE,QAAI,CAAC;AAAW,YAAM,aAAa,wBAAwB;AAC3D,WAAO;AAAA,EACT;AAAA,EAEA,MAAa,gBAAgB,EAAE,UAAU,MAAM,MAAM,GAAwE;AAC3H,QAAI;AACF,YAAM,UAAU,EAAE,GAAG,OAAO,GAAG,GAAG,GAAG,EAAE;AACvC,YAAM,OAAO,SAASC,MAAK,aAAaC,MAAK,YAAY,EAAE,CAAC;AAC5D,YAAM,MAAMA,MAAK,IAAI,kBAAkB;AACvC,YAAM,SAAS,MAAa,cAAO,UAAU,MAAM,KAAK,OAAO;AAE/D,YAAM,OAAO,CAAC,GAAG,IAAI,WAAW,MAAM,CAAC,EACpC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAC1C,KAAK,EAAE;AAEV,YAAM,YAAYD,MAAK,WAAW,IAAI;AACtC,YAAM,UAAUC,MAAK,IAAI,QAAQ,cAAc,SAAS;AACxD,YAAM,YAAYD,MAAK,aAAa,QAAQ,SAAS;AACrD,YAAM,YAAYA,MAAK,aAAa,QAAQ,SAAS;AAErD,UAAI,CAAC,aAAa,CAAC,aAAa,CAAC,MAAM;AACrC,cAAM,aAAa,qBAAqB;AAAA,MAC1C;AAEA,aAAO,EAAE,WAAW,WAAW,KAAK;AAAA,IACtC,SAAS,OAAY;AACnB,UAAI,iBAAiB;AAAY,eAAO,QAAQ,OAAO,KAAK;AAC5D,aAAO,QAAQ,OAAO,aAAa,wBAAwB;AAAA,QACzD,SAAS,gCAAgC,OAAO,WAAW,EAAE;AAAA,MAC/D,CAAC,CAAC;AAAA,IACJ;AAAA,EACF;AAAA,EAEO,WAAW,EAAE,WAAW,WAAW,KAAK,GAAgC;AAC7E,SAAK,QAAQ;AACb,QAAI,CAAC;AAAM,YAAM,aAAa,qBAAqB;AACnD,SAAK,iBAAiB,WAAW,EAAE,WAAW,UAAU,CAAC;AAAA,EAC3D;AAAA,EAEA,MAAa,QAAQ,QAA2E;AAC9F,WAAO,KAAK,iBAAiB,QAAQ,MAAM;AAAA,EAC7C;AAAA,EAEA,MAAa,QAAQ,QAA2E;AAC9F,WAAO,KAAK,iBAAiB,QAAQ,MAAM;AAAA,EAC7C;AACF;","names":["util","nacl","util","nacl","util","nacl","util","nacl"]}