{"version":3,"sources":["../../../src/controllers/Basic/index.ts","../../../src/controllers/SparkController/types.ts","../../../src/utilities/index.ts","../../../src/events/SparkEvent/index.ts","../../../src/errors/controllers.ts","../../../src/errors/spark.ts","../../../src/controllers/SparkController/index.ts"],"sourcesContent":["import { AnyKeyEvent, BaseKeyEventProps, KeyDestructionEvent, KeyEventType, KeyInceptionEvent, KeyRotationEvent } from '../SparkController/types';\nimport { SparkController } from \"../SparkController\";\nimport { KeyPairs } from '../../spark/types';\nimport { SparkErrors } from '../../errors';\nimport { ControllerErrors } from '../../errors/controllers';\nimport { SparkEvent } from '../../events/SparkEvent';\n\nexport class Basic extends SparkController {\n  public async import(data: Record<string, any>): Promise<void> {\n    if (!data) throw SparkErrors.SPARK_IMPORT_ERROR();\n    await super.import(data);\n    return Promise.resolve();\n  }\n\n  public async export(): Promise<Record<string, any>> {\n    const data = await super.export();\n    return Promise.resolve(data);\n  }\n\n  private async keyEvent({ nextKeyPairs, type }: { nextKeyPairs?: KeyPairs, type: KeyEventType.INCEPT }): Promise<KeyInceptionEvent>;\n  private async keyEvent({ nextKeyPairs, type }: { nextKeyPairs?: KeyPairs, type: KeyEventType.ROTATE }): Promise<KeyRotationEvent>;\n  private async keyEvent({ nextKeyPairs, type }: { nextKeyPairs?: KeyPairs, type: KeyEventType.DESTROY }): Promise<KeyDestructionEvent>;\n  private async keyEvent({ nextKeyPairs, type }: { nextKeyPairs?: KeyPairs, type: KeyEventType }): Promise<AnyKeyEvent> {\n    const keyPairs = this._spark.keyPairs as KeyPairs;\n    const previousKeyCommitment = this.keyEventLog[this.keyEventLog.length - 1]?.nextKeyCommitments;\n    const keyCommitment = await this._spark.hash({ data: keyPairs.signer.publicKey });\n    const nextKeyCommitments = type === KeyEventType.DESTROY ? undefined : await this._spark.hash({ data: nextKeyPairs?.signer.publicKey });\n\n    try {\n      switch (true) {\n        case type === KeyEventType.INCEPT && this.keyEventLog.length > 0:\n          throw ControllerErrors.CONTROLLER_ALREADY_INCEPTED_ERROR();\n        case type === KeyEventType.ROTATE && this.keyEventLog.length === 0:\n        case type === KeyEventType.DESTROY && this.keyEventLog.length === 0:\n          throw ControllerErrors.CONTROLLER_INCEPTION_MISSING_ERROR();\n        case type === KeyEventType.DESTROY && this.keyEventLog.length > 0 && this.keyEventLog[this.keyEventLog.length - 1].type === KeyEventType.DESTROY:\n          throw ControllerErrors.CONTROLLER_ALREADY_DESTROYED_ERROR();\n        case type !== KeyEventType.DESTROY && !nextKeyPairs:\n          throw ControllerErrors.CONTROLLER_INVALID_NEXT_KEYPAIRS_ERROR();\n        case !Object.values(KeyEventType).includes(type):\n          throw ControllerErrors.CONTROLLER_INVALID_KEY_EVENT_TYPE_ERROR();\n        case type === KeyEventType.ROTATE && previousKeyCommitment !== keyCommitment:\n          throw ControllerErrors.CONTROLLER_INVALID_NEXT_KEY_COMMITMENT_ERROR();\n        case this.keyEventLog.length > 0 && !this.keyEventLog[this.keyEventLog.length - 1].selfAddressingIdentifier:\n          throw ControllerErrors.CONTROLLER_MISSING_PREVIOUS_DIGEST_ERROR();\n      }\n\n      const baseEventProps: BaseKeyEventProps = {\n        index: this.keyEventLog.length,\n        signingThreshold: 1,\n        signingKeys: [keyPairs.signer.publicKey],\n        backerThreshold: 0,\n        backers: [],\n        nextKeyCommitments,\n      }\n\n      const eventJSON = JSON.stringify(baseEventProps);\n      const versionData = eventJSON.length.toString(16).padStart(6, '0');\n      const version = 'KERI10JSON' + versionData + '_';\n      const hashedEvent = await this._spark.hash({ data: eventJSON });\n      const selfAddressingIdentifier = await this._spark.seal({ data: hashedEvent });\n      const identifier = this._identifier || `B${selfAddressingIdentifier}`;\n      const previousEventDigest = this.keyEventLog[this.keyEventLog.length - 1]?.selfAddressingIdentifier;\n\n      const commonEventProps = {\n        identifier,\n        type,\n        version,\n        ...baseEventProps,\n        selfAddressingIdentifier,\n      }\n\n      switch (type) {\n        case KeyEventType.INCEPT:\n          return {\n            ...commonEventProps,\n            type: KeyEventType.INCEPT,\n          };\n        case KeyEventType.ROTATE:\n          return {\n            ...commonEventProps,\n            type: KeyEventType.ROTATE,\n            previousEventDigest,\n          };\n        case KeyEventType.DESTROY:\n          return {\n            ...commonEventProps,\n            type: KeyEventType.DESTROY,\n            previousEventDigest,\n            nextKeyCommitments: [],\n            signingKeys: []\n          };\n        default:\n          throw ControllerErrors.CONTROLLER_INVALID_KEY_EVENT_TYPE_ERROR();\n      }\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(ControllerErrors.CONTROLLER_UNEXPECTED_ERROR({\n        message: `Failed to create key event. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async incept(): Promise<void> {\n    try {\n      const keyPairs = this._spark.keyPairs as KeyPairs;\n      const inceptionEvent = await this.keyEvent({ nextKeyPairs: keyPairs, type: KeyEventType.INCEPT }) as KeyInceptionEvent;\n      this.keyEventLog.push(inceptionEvent);\n      this._identifier = inceptionEvent.identifier;\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  public async rotate({ nextKeyPairs }: { nextKeyPairs: KeyPairs }): Promise<void> {\n    try {\n      const rotationEvent = await this.keyEvent({ nextKeyPairs, type: KeyEventType.ROTATE }) as KeyRotationEvent;\n      this.keyEventLog.push(rotationEvent);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  public async destroy(): Promise<void> {\n    try {\n      const destructionEvent = await this.keyEvent({ type: KeyEventType.DESTROY }) as KeyDestructionEvent;\n      this.keyEventLog.push(destructionEvent);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n}","import { HashDigest } from \"../../hashers/SparkHasher/types\";\nimport { SignerPublicKey } from \"../../signers/SparkSigner/types\";\n\nexport enum ControllerType {\n  CORE_CONTROLLER = 'CORE_CONTROLLER',\n  BASIC_CONTROLLER = 'BASIC_CONTROLLER',\n}\n\nexport type Identifier = string;\n\n// primitives\nexport type SigningThreshold = number;                    // kt: minimum amount of signatures needed for this event to be valid (multisig)\nexport type SequenceIndex = number;                       // s: sequence number\nexport type SigningKeys = SignerPublicKey[];             // k: list of signing key\nexport type NextKeyCommitments = HashDigest[];            // n: next keys\nexport type Backer = SignerPublicKey;                    // b: individual backer\nexport type BackerThreshold = number;                     // bt: minimum amount of backers threshold\nexport type SelfAddressingIdentifier = HashDigest;        // d: self-addressing identifier\nexport type Version = string;                             // v: version\nexport type PreviousEventDigest = HashDigest;             // p: previous event digest\n\n// enums\nexport enum KeyEventType {\n  INCEPT = 'INCEPT',\n  ROTATE = 'ROTATE',\n  DESTROY = 'DESTROY',\n}\n\n// events\nexport interface KeyInceptionEvent {\n  type: KeyEventType.INCEPT;                                // t: event type\n  identifier: Identifier;                                   // s: sequence number\n  version: Version;                                         // v: version\n  index: SequenceIndex;                                     // i: inception event index\n  signingThreshold: SigningThreshold;                       // kt: minimum amount of signatures needed for this event to be valid (multisig)\n  signingKeys: SigningKeys;                                 // k: list of signing key\n  nextKeyCommitments: NextKeyCommitments;                   // n: next keys\n  backerThreshold: BackerThreshold;                         // bt: minimum amount of backers threshold\n  backers: Backer[];                                        // b: list of backers in this case the spark pwa-agent host's publickey there's no receipt at this ste\n  selfAddressingIdentifier: SelfAddressingIdentifier;       // d: self-addressing identifier\n}\n\nexport interface KeyRotationEvent {\n  type: KeyEventType.ROTATE;                                // t: event type\n  identifier: Identifier;                                   // s: sequence number\n  version: Version;                                         // v: version\n  index: SequenceIndex;                                        // i: inception event index\n  signingThreshold: SigningThreshold;                       // kt: minimum amount of signatures needed for this event to be valid (multisig)\n  signingKeys: SigningKeys;                                 // k: list of signing key\n  nextKeyCommitments: NextKeyCommitments;                   // n: next keys\n  backerThreshold: BackerThreshold;                         // bt: minimum amount of backers threshold\n  backers: Backer[];                                        // b: list of backers in this case the spark pwa-agent host's publickey there's no receipt at this ste\n  selfAddressingIdentifier: SelfAddressingIdentifier;       // d: self-addressing identifier\n  previousEventDigest: PreviousEventDigest;                 // p: previous event digest\n}\n\nexport interface KeyDestructionEvent {\n  type: KeyEventType.DESTROY;                               // t: event type\n  identifier: Identifier;                                   // s: sequence number\n  version: Version;                                         // v: version\n  index: SequenceIndex;                                        // i: inception event index\n  signingThreshold: SigningThreshold;                       // kt: minimum amount of signatures needed for this event to be valid (multisig)\n  signingKeys: SigningKeys;                                 // k: list of signing key\n  nextKeyCommitments: NextKeyCommitments;                   // n: next keys\n  backerThreshold: BackerThreshold;                         // bt: minimum amount of backers threshold\n  backers: Backer[];                                        // b: list of backers in this case the spark pwa-agent host's publickey there's no receipt at this ste\n  selfAddressingIdentifier: SelfAddressingIdentifier;       // d: self-addressing identifier\n  previousEventDigest: PreviousEventDigest;                 // p: previous event digest\n}\n\n// unions\nexport type AnyKeyEvent = KeyInceptionEvent | KeyRotationEvent | KeyDestructionEvent;\n\n// base is anything common that doesn't need to be computed\nexport type BaseKeyEventProps = Omit<AnyKeyEvent, 'type' | 'identifier' | 'version' | 'selfAddressingIdentifier'>;\n\nexport type KeyEventMap = {\n  [KeyEventType.INCEPT]: KeyInceptionEvent;\n  [KeyEventType.ROTATE]: KeyRotationEvent;\n  [KeyEventType.DESTROY]: KeyDestructionEvent;\n}\n\n// collections\nexport type KeyEventLog = AnyKeyEvent[]\n\nexport interface SparkControllerInterface {\n  readonly identifier: Identifier;\n  readonly keyEventLog: KeyEventLog;\n\n  import(data: Record<string, any>): Promise<void>;\n  export(): Promise<Record<string, any>>;\n\n  incept(params?: Record<string, any>): Promise<void>;\n  rotate(params?: Record<string, any>): Promise<void>;\n  destroy(params?: Record<string, any>): Promise<void>;\n}","import nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { createId, isCuid } from '@paralleldrive/cuid2';\n\n/**\n * @returns a timestamp in milliseconds since epoch in terms of UTC\n */\nexport function utcEpochTimestamp() {\n  const now = new Date()\n  return now.getTime() + now.getTimezoneOffset() * 60 * 1000;\n}\n\n/**\n * @returns a parsed json string or null if it fails\n */\nexport function parseJSON(data: string) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n}\n\n/**\n * @returns a new unique salt\n */\nexport function randomSalt(len: number = 32) {\n  return util.encodeBase64(nacl.randomBytes(len));\n}\n\n/**\n * @returns a new unique identifier\n */\nexport function randomCuid() {\n  return createId();\n}\n\n/**\n * @returns whether the identifier is a valid CUID\n */\nexport function validCuid(id: string) {\n  return isCuid(id);\n}\n\n/**\n * SNAKE_CASE to PascalCase\n * @returns a PascalCase string\n */\nexport function snakeToPascal(str: string) {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, char) => char.toUpperCase()).replace(/^[a-z]/, char => char.toUpperCase());\n}","import { randomCuid, utcEpochTimestamp } from \"../../utilities\";\nimport { ConfirmEventType, CreateEventFunction, CreateEventParams, ErrorEventType, RequestEventType, SparkEventInterface, SparkEventParams } from \"./types\";\n\n\nexport class SparkEvent implements SparkEventInterface {\n  readonly type:  RequestEventType | ConfirmEventType | ErrorEventType;\n  readonly timestamp: number;\n  readonly metadata: Record<string, any>;\n  readonly data: Record<string, any>;\n  readonly digest: string;\n\n  constructor(args: SparkEventParams) {\n    this.type = args.type;\n    this.metadata = args.metadata;\n    this.timestamp = args.timestamp;\n    if (args.data) this.data = args.data;\n    if (args.digest) this.digest = args.digest;\n  }\n}\n\nexport class SparkRequestEvent extends SparkEvent {\n  declare readonly type: RequestEventType;\n}\nexport class SparkConfirmEvent extends SparkEvent {\n  declare readonly type: ConfirmEventType;\n}\nexport class SparkErrorEvent extends SparkEvent {\n  declare readonly type: ErrorEventType;\n}\n\nexport const createEvent: CreateEventFunction = (params: CreateEventParams): any => {\n  const { type, data, digest } = params;\n  const timestamp: number = utcEpochTimestamp();\n  const metadata = { ...(params.metadata || {}), eventId: randomCuid() };\n\n  const invalidEvent = (!type.endsWith(\"_REQUEST\") && !type.endsWith(\"_CONFIRM\") && !type.endsWith(\"_ERROR\"));\n  const invalidParams = !!((data && digest) || (!data && !digest));\n\n  let event;\n  if (!!data) event = new SparkEvent({ type, metadata, timestamp, data });\n  else if (!!digest) event = new SparkEvent({ type, metadata, timestamp, digest });\n  else event = null;\n\n  if (invalidEvent || invalidParams || !event) {\n    throw new SparkEvent({\n      type: 'CREATE_EVENT_ERROR',\n      metadata: {\n        eventId: randomCuid()\n      },\n      timestamp,\n      data: { message: invalidEvent ? `Invalid event type: ${type}` : `Invalid event params: ${JSON.stringify(params)}` },\n    });\n  }\n\n  // TODO - settings for optional logging\n  const isError = event.type.endsWith(\"_ERROR\");\n  // if (isError) console.error(event);\n\n  return event;\n};\n","import { createEvent } from \"../events/SparkEvent\";\n\nexport const ControllerErrorTypes = {\n  CONTROLLER_ALREADY_INCEPTED_ERROR: 'CONTROLLER_ALREADY_INCEPTED_ERROR',\n  CONTROLLER_INCEPTION_MISSING_ERROR: 'CONTROLLER_INCEPTION_MISSING_ERROR',\n  CONTROLLER_ALREADY_DESTROYED_ERROR: 'CONTROLLER_ALREADY_DESTROYED_ERROR',\n  CONTROLLER_INVALID_NEXT_KEYPAIRS_ERROR: 'CONTROLLER_INVALID_NEXT_KEYPAIRS_ERROR',\n  CONTROLLER_INVALID_KEY_EVENT_TYPE_ERROR: 'CONTROLLER_INVALID_KEY_EVENT_TYPE_ERROR',\n  CONTROLLER_INVALID_NEXT_KEY_COMMITMENT_ERROR: 'CONTROLLER_INVALID_NEXT_KEY_COMMITMENT_ERROR',\n  CONTROLLER_MISSING_PREVIOUS_DIGEST_ERROR: 'CONTROLLER_MISSING_PREVIOUS_DIGEST_ERROR',\n  CONTROLLER_MISSING_IDENTIFIER_ERROR: 'CONTROLLER_MISSING_IDENTIFIER_ERROR',\n  CONTROLLER_UNEXPECTED_ERROR: 'CONTROLLER_UNEXPECTED_ERROR',\n} as const;\n\nexport const ControllerErrors = {\n  CONTROLLER_ALREADY_INCEPTED_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_ALREADY_INCEPTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Controller already incepted.' }\n  }),\n  CONTROLLER_INCEPTION_MISSING_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_INCEPTION_MISSING_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Missing controller inception.' }\n  }),\n  CONTROLLER_ALREADY_DESTROYED_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_ALREADY_DESTROYED_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Controller already destroyed.' }\n  }),\n  CONTROLLER_INVALID_NEXT_KEYPAIRS_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_INVALID_NEXT_KEYPAIRS_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Invalid next keypairs.' }\n  }),\n  CONTROLLER_INVALID_KEY_EVENT_TYPE_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_INVALID_KEY_EVENT_TYPE_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Invalid key event type.' }\n  }),\n  CONTROLLER_INVALID_NEXT_KEY_COMMITMENT_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_INVALID_NEXT_KEY_COMMITMENT_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Invalid next key commitment.' }\n  }),\n  CONTROLLER_MISSING_PREVIOUS_DIGEST_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_MISSING_PREVIOUS_DIGEST_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Missing previous key event digest.' }\n  }),\n  CONTROLLER_MISSING_IDENTIFIER_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_MISSING_IDENTIFIER_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Missing controller identifier.' }\n  }),\n  CONTROLLER_UNEXPECTED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ControllerErrorTypes.CONTROLLER_UNEXPECTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected controller error.' }\n  }),\n}","import { createEvent } from \"../events/SparkEvent\";\n\nexport const SparkErrorTypes = {\n  SPARK_IMPORT_ERROR: 'SPARK_IMPORT_ERROR',\n  SPARK_EXPORT_ERROR: 'SPARK_EXPORT_ERROR',\n  SPARK_UNEXPECTED_ERROR: 'SPARK_UNEXPECTED_ERROR',\n} as const;\n\nexport const SparkErrors = {\n  SPARK_IMPORT_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SparkErrorTypes.SPARK_IMPORT_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to import data.' }\n  }),\n  SPARK_EXPORT_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SparkErrorTypes.SPARK_EXPORT_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to export data.' }\n  }),\n  SPARK_UNEXPECTED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: SparkErrorTypes.SPARK_UNEXPECTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected spark error.' }\n  }),\n}\n\n","import { SparkErrors } from \"../../errors\";\nimport { SparkInterface } from \"../../spark/types\";\nimport { Identifier, KeyEventLog, SparkControllerInterface } from \"./types\";\n\nexport abstract class SparkController implements SparkControllerInterface {\n  protected _identifier: Identifier;\n  protected _keyEventLog: KeyEventLog;\n  protected _spark: SparkInterface<any, any, any, any, any>;\n\n  constructor(spark: SparkInterface<any, any, any, any, any>) {\n    this._spark = spark;\n    this._keyEventLog = [];\n    this.incept = this.incept.bind(this);\n    this.rotate = this.rotate.bind(this);\n    this.destroy = this.destroy.bind(this);\n  }\n\n  public get identifier(): Identifier {\n    return this._identifier;\n  }\n\n  public get keyEventLog(): KeyEventLog {\n    return this._keyEventLog;\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    if (!data.identifier || !data.keyEventLog) throw SparkErrors.SPARK_IMPORT_ERROR();\n    this._identifier = data.identifier;\n    this._keyEventLog = data.keyEventLog;\n    return Promise.resolve();\n  }\n  \n  public async export(): Promise<Record<string, any>> {\n    if (!this._identifier || !this._keyEventLog) throw SparkErrors.SPARK_EXPORT_ERROR();\n    return Promise.resolve({\n      identifier: this._identifier,\n      keyEventLog: this._keyEventLog,\n    });\n  }\n\n  public abstract incept(params?: Record<string, any>): Promise<void>;\n  public abstract rotate(params?: Record<string, any>): Promise<void>;\n  public abstract destroy(params?: Record<string, any>): Promise<void>;\n}"],"mappings":"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","names":["KeyEventType"]}