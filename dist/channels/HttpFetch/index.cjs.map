{"version":3,"sources":["../../../src/channels/HttpFetch/index.ts","../../../src/channels/SparkChannel/index.ts","../../../src/utilities/index.ts","../../../src/events/SparkEvent/index.ts","../../../src/errors/channels.ts","../../../src/channels/SparkChannel/events.ts","../../../src/channels/SparkChannel/types.ts"],"sourcesContent":["import { SparkEvent } from \"../../events/SparkEvent\";\nimport { SparkChannel } from \"../SparkChannel\";\nimport { SparkChannelActions, SparkChannelInterface } from \"../SparkChannel/types\";\nimport { HttpFetchParams } from \"./types\";\n\nexport class HttpFetch extends SparkChannel implements SparkChannelInterface<SparkChannelActions> {\n\n  constructor({ peer, ...params }: HttpFetchParams) {\n    const type = 'HttpFetch';\n    super({ ...params, type, peer });\n    this.peer.url = peer.url;\n    this.peer.origin = peer?.origin ? peer.origin : new URL(peer.url).origin;\n  }\n\n  public async sendEvent(payload: SparkEvent) {\n    const response = await fetch(this.peer.url, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(payload),\n    });\n    const json = await response.json();\n    if (!json.error) this.handleEvent(json);\n  }\n\n  static receive() {\n    throw new Error(\"Fetch channels are outgoing only\");\n  }\n}","import EventEmitter from \"eventemitter3\";\nimport { ChannelErrors } from \"../../errors\";\nimport { SparkConfirmEvent, SparkErrorEvent, SparkEvent, SparkRequestEvent, createEvent } from \"../../events/SparkEvent\";\nimport { ErrorEventType, EventType } from \"../../events/SparkEvent/types\";\nimport { Spark } from \"../../spark/Spark\";\nimport { randomCuid, snakeToPascal, validCuid } from \"../../utilities\";\nimport { ChannelEventTypes, ChannelEvents, DigestTypes, ReceiptTypes } from \"./events\";\nimport { ChannelExport, ChannelId, ChannelLoggedEvent, ChannelPeer, ChannelState, ChannelType, OnConfirmMethod, OnRequestMethod, RequestOptions, RequestParams, SparkChannelActions, SparkChannelInterface } from \"./types\";\nimport { SignerPublicKey } from \"../../signers/SparkSigner/types\";\n\nexport abstract class SparkChannel extends EventEmitter implements SparkChannelInterface<SparkChannelActions> {\n  protected _spark: Spark<any, any, any, any, any>;\n  private _channelId: ChannelId;\n  private _type: ChannelType;\n  private _peer: ChannelPeer;\n  private _state: ChannelState;\n  private _eventLog: ChannelLoggedEvent[];\n  private _eventTypes: {\n    ANY_EVENT: 'ANY_EVENT',\n    ANY_REQUEST: 'ANY_REQUEST',\n    ANY_CONFIRM: 'ANY_CONFIRM',\n    ANY_ERROR: 'ANY_ERROR',\n  } & { [key: string]: EventType };\n\n  constructor(params: {\n    type: ChannelType,\n    spark: Spark<any, any, any, any, any>,\n    channelId?: ChannelId,\n    peer?: ChannelPeer,\n    state?: ChannelState,\n    eventLog?: ChannelLoggedEvent[],\n    actions?: string[],\n  }) {\n    super();\n\n    this._spark = params.spark;\n\n    this._channelId = params.channelId || randomCuid();\n    this._type = params.type;\n    this._spark = params.spark;\n    this._state = { open: false, ...(params.state || {}) };\n    this._eventLog = params.eventLog || [];\n    if (params.peer) {\n      this._peer = { ...params.peer };\n    }\n\n    const actions = (params?.actions || []).concat(SparkChannelActions);\n\n    this._eventTypes = {\n      ANY_EVENT: 'ANY_EVENT',\n      ANY_REQUEST: 'ANY_REQUEST',\n      ANY_CONFIRM: 'ANY_CONFIRM',\n      ANY_ERROR: 'ANY_ERROR',\n    } as any;\n    for (const action of actions) {\n      this._eventTypes[`${action}_REQUEST`] = `${action}_REQUEST`;\n      this._eventTypes[`${action}_CONFIRM`] = `${action}_CONFIRM`;\n      this._eventTypes[`${action}_REQUEST_ERROR`] = `${action}_REQUEST_ERROR`;\n      this._eventTypes[`${action}_CONFIRM_ERROR`] = `${action}_CONFIRM_ERROR`;\n    }\n\n    const sendEvent = this.sendEvent.bind(this);\n    this.sendEvent = async (event: SparkEvent) => {\n      await sendEvent(event);\n      this.eventLog.push({ event, request: true });\n    }\n\n    this.sendEvent = this.sendEvent.bind(this);\n    this.handleEvent = this.handleEvent.bind(this);\n  }\n\n  get channelId(): ChannelId { return this._channelId; }\n  get type(): ChannelType { return this._type; }\n  get peer(): ChannelPeer { return this._peer; }\n  get state(): ChannelState { return this._state; }\n  get eventLog(): ChannelLoggedEvent[] { return this._eventLog; }\n  get eventTypes(): { [key: string]: EventType } { return this._eventTypes; }\n\n  private async isValidEventPayload(payload: any = {}) {\n    const { type, data, digest, timestamp, metadata } = payload || {};\n    if (!type || !(data || digest) || !timestamp || !metadata) return false;\n    const validEventType = type && this.eventTypes[type];\n    const validPayload = data || digest && !(data && digest);\n    const validTimestamp = timestamp && typeof timestamp === 'number';\n    const validMetadata = metadata && typeof metadata === 'object';\n    const validChannelId = metadata?.channelId === this.channelId && validCuid(metadata?.channelId);\n    const validEventId = metadata?.eventId && validCuid(metadata?.eventId);\n    return validEventType && validPayload && validTimestamp && validMetadata && validChannelId && validEventId;\n  }\n\n  private getRequestMethodName(type: EventType): OnRequestMethod<SparkChannelActions[number]> {\n    const baseType = type.replace('_REQUEST', '');\n    const camelType = snakeToPascal(baseType);\n    return `on${camelType}Requested` as OnRequestMethod<SparkChannelActions[number]>;\n  }\n\n  private getConfirmMethodName(type: EventType): OnConfirmMethod<SparkChannelActions[number]> {\n    const baseType = type.replace('_CONFIRM', '');\n    const camelType = snakeToPascal(baseType);\n    return `on${camelType}Confirmed` as OnConfirmMethod<SparkChannelActions[number]>;\n  }\n\n  public async getEventData(event: SparkEvent, ourEvent?: boolean) {\n    const { data, digest } = event;\n    if (!digest && data) return data;\n    const publicKey = ourEvent ? this._spark.publicKeys?.signer : this.peer?.publicKeys?.signer;\n    const opened = await this._spark.signer.open({ signature: digest, publicKey });\n    const decrypted = await this._spark.cipher.decrypt({ data: opened, sharedKey: this.peer.sharedKey });\n    return decrypted;\n  }\n\n  public async getReceiptData(event: SparkEvent) {\n    const data = await this.getEventData(event);\n    const { receipt } = data;\n    const opened = await this._spark.signer.open({ signature: receipt, publicKey: this.peer?.publicKeys?.signer });\n    return opened;\n  }\n\n  protected async dispatchRequest(\n    event: SparkRequestEvent,\n    { timeout = 10000, retries = 0 }: { timeout?: number, retries?: number } = {}\n  ): Promise<SparkConfirmEvent> {\n    return new Promise((resolve, reject) => {\n      const { type, metadata } = event;\n      const confirmType = type.replace('_REQUEST', '_CONFIRM');\n      const errorType = `${confirmType}_ERROR`;\n      let timeoutId: NodeJS.Timer;\n\n      const onConfirm = async (confirm: SparkConfirmEvent) => {\n        try {\n          if (confirm.type !== confirmType) return;\n          const receipt = await this.getReceiptData(confirm);\n          if (receipt.metadata.eventId !== metadata.eventId) return;\n          clearTimeout(timeoutId);\n          this.off(confirmType, onConfirm);\n          resolve(confirm);\n        } catch(error) {\n          reject(error);\n        }\n      }\n      this.on(confirmType, onConfirm);\n\n      const onError = (error: SparkErrorEvent) => {\n        const requestId = error.metadata.request.eventId;\n        if (requestId !== event.metadata.eventId) return;\n        clearTimeout(timeoutId);\n        this.off(confirmType, onConfirm);\n        this.off(error.type, onError);\n        reject(error);\n      }\n      this.on(errorType, onError);\n\n      timeoutId = setTimeout(() => {\n        this.off(confirmType, onConfirm);\n        this.off(errorType, onError);\n\n        if (retries > 0) {\n          this.dispatchRequest(event, { timeout, retries: retries - 1 })\n            .then(resolve)\n            .catch(reject);\n          return;\n        }\n\n        const timeoutError = ChannelErrors.CHANNEL_REQUEST_TIMEOUT_ERROR({\n          metadata: { channelId: this.channelId },\n          message: `Timeout waiting for ${confirmType} event.`,\n        });\n\n        this.emit(timeoutError.type, timeoutError);\n        reject(timeoutError);\n      }, timeout);\n\n      this.sendEvent(event)\n    });\n  }\n\n  protected abstract sendEvent(event: SparkEvent): Promise<void>;\n\n  protected async handleEvent(payload: any = {}) {\n    try {\n      if (!this.isValidEventPayload(payload)) {\n        return Promise.resolve();\n      }\n      \n      const { type, data, digest, timestamp, metadata } = payload || {};\n      switch (true) {\n        case type.endsWith('_REQUEST'):\n          const request = new SparkRequestEvent({ type, data, digest, timestamp, metadata });\n          const onRequestMethod = this.getRequestMethodName(type);\n          await this[onRequestMethod](request);\n          this.eventLog.push({ event: request, response: true });\n          this.emit(type, request);\n          break;\n        case type.endsWith('_CONFIRM'):\n          const confirm = new SparkConfirmEvent({ type, data, digest, timestamp, metadata });\n          const onConfirmMethod = this.getConfirmMethodName(type);\n          await this[onConfirmMethod](confirm);\n          this.eventLog.push({ event: confirm, response: true });\n          this.emit(type, confirm);\n          break;\n        case type.endsWith('_ERROR'):\n          const error = new SparkErrorEvent({ type, data, digest, timestamp, metadata });\n          this.emit(type, error);\n          break;\n      }\n    } catch (error: any) {\n      console.log(error)\n      const type = `${payload.type}_ERROR` as ErrorEventType;\n      const metadata = payload.type.endsWith('_REQUEST') ? \n        { channelId: this.channelId, request: payload?.metadata } : \n        { channelId: this.channelId, confirm: payload?.metadata };\n      const data = { message: error?.message };\n      const errorEvent = createEvent({ type, metadata, data });\n      this.emit(type, errorEvent);\n      await this.sendEvent(errorEvent);\n      return Promise.reject(errorEvent);\n    }\n  }\n\n  import(params: ChannelExport): void {\n    const { channelId, type, peer, eventLog } = params;\n    this._channelId = channelId;\n    this._type = type;\n    this._peer = peer;\n    this._eventLog = eventLog;\n  }\n\n  export(): ChannelExport {\n    return {\n      channelId: this.channelId,\n      type: this.type,\n      peer: this.peer,\n      eventLog: this.eventLog,\n    }\n  }\n\n  async open(params?: RequestParams, options?: RequestOptions) {\n    if (!this._spark.identifier || !this._spark.publicKeys || !this._spark.publicKeys.signer || !this._spark.publicKeys.cipher) {\n      throw ChannelErrors.CHANNEL_INVALID_PEER_INFO_ERROR({ metadata: { channelId: this.channelId } });\n    }\n\n    const request = ChannelEvents.OPEN_REQUEST({\n      metadata: { channelId: this.channelId },\n      data: {\n        identifier: this._spark.identifier,\n        publicKeys: this._spark.publicKeys,\n        ...(params?.data || {}),\n      }\n    });\n\n    await this.dispatchRequest(request, options)\n    return Promise.resolve(this);\n  }\n\n  async onOpenRequested(event: SparkRequestEvent) {\n    const { data: { identifier, publicKeys }} = event;\n\n    if (!identifier || !publicKeys || !publicKeys.signer || !publicKeys.cipher) {\n      throw ChannelErrors.CHANNEL_INVALID_PEER_INFO_ERROR({ metadata: { channelId: this.channelId } });\n    }\n\n    this.peer.sharedKey = await this._spark.cipher.generateSharedKey({ publicKey: publicKeys.cipher });\n    this.peer.identifier = identifier;\n    this.peer.publicKeys = publicKeys;\n\n    const confirm = await this.confirmOpen(event);\n    this.state.open = true;\n    return confirm;\n  }\n\n  async confirmOpen(event: SparkRequestEvent) {\n    const receiptData: ReceiptTypes['OPEN_REQUEST'] = {\n      type: ChannelEventTypes.OPEN_REQUEST,\n      timestamp: event.timestamp,\n      metadata: { channelId: this.channelId, eventId: event.metadata.eventId },\n      data: { peers: [ this._spark.identifier, this.peer.identifier ] }\n    };\n\n    const confirm = ChannelEvents.OPEN_CONFIRM<typeof receiptData>({\n      metadata: { channelId: this.channelId },\n      data: {\n        identifier: this._spark.identifier,\n        publicKeys: this._spark.publicKeys,\n        receipt: await this._spark.signer.seal({ data: receiptData }),\n      }\n    });\n\n    return this.sendEvent(confirm);\n  }\n\n  async onOpenConfirmed(event: SparkConfirmEvent) {\n    const { data } = event;\n    const { identifier, publicKeys, receipt } = data;\n\n    if (!identifier || !publicKeys || !publicKeys.signer || !publicKeys.cipher) {\n      throw ChannelErrors.CHANNEL_INVALID_PEER_INFO_ERROR({ metadata: { channelId: this.channelId } });\n    }\n\n    this.peer.sharedKey = await this._spark.cipher.generateSharedKey({ publicKey: publicKeys.cipher });\n    this.peer.identifier = identifier;\n    this.peer.publicKeys = publicKeys;\n    this.state.open = true;\n\n    return Promise.resolve();\n  }\n\n  async close(params?: RequestParams, options?: RequestOptions): Promise<SparkConfirmEvent> {\n    if (!this.state.open) throw ChannelErrors.CHANNEL_CLOSED_ERROR({ metadata: { channelId: this.channelId } });\n\n    const request = ChannelEvents.CLOSE_REQUEST({\n      metadata: { channelId: this.channelId },\n      data: { ...(params?.data || {}) }\n    });\n\n    return this.dispatchRequest(request, options)\n  }\n\n  async onCloseRequested(event: SparkRequestEvent) {\n    const confirm = await this.confirmClose(event);\n    this.state.open = false;\n    return confirm;\n  }\n\n  async confirmClose(event: SparkRequestEvent) {\n    const receiptData: ReceiptTypes['CLOSE_REQUEST'] = {\n      type: ChannelEventTypes.CLOSE_REQUEST,\n      timestamp: event.timestamp,\n      metadata: { channelId: this.channelId, eventId: event.metadata.eventId },\n      data: {\n        peers: [\n          this._spark.identifier,\n          this.peer.identifier,\n        ]\n      }\n    };\n\n    const receipt = await this._spark.signer.seal({ data: receiptData })\n\n    const confirm = ChannelEvents.CLOSE_CONFIRM<typeof receiptData>({\n      metadata: { channelId: this.channelId },\n      data: { receipt }\n    });\n\n    return this.sendEvent(confirm);\n  }\n\n  async onCloseConfirmed(event: SparkConfirmEvent) {\n    this.state.open = false;\n    return Promise.resolve();\n  }\n\n  async message(message: any, options?: RequestOptions) {\n    if (!this.state.open) {\n      throw ChannelErrors.CHANNEL_CLOSED_ERROR({ metadata: { channelId: this.channelId } });\n    }\n\n    if (!message) {\n      throw ChannelErrors.CHANNEL_INVALID_MESSAGE_ERROR({ metadata: { channelId: this.channelId } })\n    }\n\n    const data = { message };\n    const encrypted = await this._spark.cipher.encrypt({ data, sharedKey: this.peer.sharedKey });\n    const digest = await this._spark.signer.seal({ data: encrypted });\n\n    const request = ChannelEvents.MESSAGE_REQUEST<typeof data>({\n      metadata: { channelId: this.channelId },\n      digest,\n    });\n\n    return this.dispatchRequest(request, options);\n  }\n\n  async onMessageRequested(event: SparkRequestEvent) {\n    await this.confirmMessage(event);\n  }\n\n  async confirmMessage(event: SparkRequestEvent) {\n    if (!this.state.open) {\n      throw ChannelErrors.CHANNEL_CLOSED_ERROR({ metadata: { channelId: this.channelId } });\n    }\n\n    const { digest } = event;\n    if (!digest) {\n      throw ChannelErrors.CHANNEL_INVALID_MESSAGE_ERROR({ metadata: { channelId: this.channelId } });\n    }\n\n    const opened = await this._spark.signer.open({ signature: digest, publicKey: this.peer?.publicKeys?.signer });\n    const decrypted = await this._spark.cipher.decrypt({ data: opened, sharedKey: this.peer.sharedKey });\n\n    const receiptData: ReceiptTypes['MESSAGE_REQUEST'] = {\n      type: ChannelEventTypes.MESSAGE_REQUEST,\n      timestamp: event.timestamp,\n      metadata: { channelId: this.channelId, eventId: event.metadata.eventId },\n      data: decrypted\n    };\n\n    const digestData: DigestTypes['MESSAGE_CONFIRM'] = {\n      receipt: await this._spark.signer.seal({ data: receiptData }),\n    };\n    \n    const encrypted = await this._spark.cipher.encrypt({ data: digestData, sharedKey: this.peer.sharedKey });\n    const confirmDigest = await this._spark.signer.seal({ data: encrypted });\n\n    const confirm = ChannelEvents.MESSAGE_CONFIRM<typeof digestData>({\n      metadata: { channelId: this.channelId },\n      digest: confirmDigest,\n    });\n\n    return this.sendEvent(confirm);\n  }\n\n  async onMessageConfirmed(event: SparkConfirmEvent) {\n    return Promise.resolve();\n  }\n\n  // extend event emitter to accomodate arrays of events for listeners and emitter methods\n  emit<T extends string | symbol>(event: T, ...args: any[]): boolean {\n    const emitted = super.emit(event, ...args);\n    const type = event as EventType;\n    \n    if (type.endsWith('_REQUEST') || type.endsWith('_CONFIRM')) {\n      super.emit('ANY_EVENT', ...args);\n    }\n\n    if (type.endsWith('_REQUEST')) {\n      super.emit('ANY_REQUEST', ...args);\n    }\n\n    if (type.endsWith('_CONFIRM')) {\n      super.emit('ANY_CONFIRM', ...args);\n    }\n\n    if (type.endsWith('_ERROR')) {\n      super.emit('ANY_ERROR', ...args);\n    }\n\n    return emitted;\n  }\n\n  on<T extends string | symbol>(event: T | T[], listener: (...args: any[]) => void): this {\n    if (Array.isArray(event)) {\n      for (const e of event) {\n        super.on(e, listener);\n      }\n      return this;\n    }\n    return super.on(event, listener);\n  }\n\n  once<T extends string | symbol>(event: T | T[], listener: (...args: any[]) => void): this {\n    if (Array.isArray(event)) {\n      for (const e of event) {\n        super.once(e, listener);\n      }\n      return this;\n    }\n    return super.once(event, listener);\n  }\n\n  off<T extends string | symbol>(event: T | T[], listener: (...args: any[]) => void): this {\n    if (Array.isArray(event)) {\n      for (const e of event) {\n        super.off(e, listener);\n      }\n      return this;\n    }\n    return super.off(event, listener);\n  }\n\n  removeListener<T extends string | symbol>(event: T, fn?: ((...args: any[]) => void) | undefined, context?: any, once?: boolean | undefined): this {\n    if (Array.isArray(event)) {\n      for (const e of event) {\n        super.removeListener(e, fn, context, once);\n      }\n      return this;\n    }\n    return super.removeListener(event, fn, context, once);\n  }\n}","import nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { createId, isCuid } from '@paralleldrive/cuid2';\n\n/**\n * @returns a timestamp in milliseconds since epoch in terms of UTC\n */\nexport function utcEpochTimestamp() {\n  const now = new Date()\n  return now.getTime() + now.getTimezoneOffset() * 60 * 1000;\n}\n\n/**\n * @returns a parsed json string or null if it fails\n */\nexport function parseJSON(data: string) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n}\n\n/**\n * @returns a new unique salt\n */\nexport function randomSalt(len: number = 32) {\n  return util.encodeBase64(nacl.randomBytes(len));\n}\n\n/**\n * @returns a new unique identifier\n */\nexport function randomCuid() {\n  return createId();\n}\n\n/**\n * @returns whether the identifier is a valid CUID\n */\nexport function validCuid(id: string) {\n  return isCuid(id);\n}\n\n/**\n * SNAKE_CASE to PascalCase\n * @returns a PascalCase string\n */\nexport function snakeToPascal(str: string) {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, char) => char.toUpperCase()).replace(/^[a-z]/, char => char.toUpperCase());\n}","import { randomCuid, utcEpochTimestamp } from \"../../utilities\";\nimport { ConfirmEventType, CreateEventFunction, CreateEventParams, ErrorEventType, RequestEventType, SparkEventInterface, SparkEventParams } from \"./types\";\n\n\nexport class SparkEvent implements SparkEventInterface {\n  readonly type:  RequestEventType | ConfirmEventType | ErrorEventType;\n  readonly timestamp: number;\n  readonly metadata: Record<string, any>;\n  readonly data: Record<string, any>;\n  readonly digest: string;\n\n  constructor(args: SparkEventParams) {\n    this.type = args.type;\n    this.metadata = args.metadata;\n    this.timestamp = args.timestamp;\n    if (args.data) this.data = args.data;\n    if (args.digest) this.digest = args.digest;\n  }\n}\n\nexport class SparkRequestEvent extends SparkEvent {\n  declare readonly type: RequestEventType;\n}\nexport class SparkConfirmEvent extends SparkEvent {\n  declare readonly type: ConfirmEventType;\n}\nexport class SparkErrorEvent extends SparkEvent {\n  declare readonly type: ErrorEventType;\n}\n\nexport const createEvent: CreateEventFunction = (params: CreateEventParams): any => {\n  const { type, data, digest } = params;\n  const timestamp: number = utcEpochTimestamp();\n  const metadata = { ...(params.metadata || {}), eventId: randomCuid() };\n\n  const invalidEvent = (!type.endsWith(\"_REQUEST\") && !type.endsWith(\"_CONFIRM\") && !type.endsWith(\"_ERROR\"));\n  const invalidParams = !!((data && digest) || (!data && !digest));\n\n  let event;\n  if (!!data) event = new SparkEvent({ type, metadata, timestamp, data });\n  else if (!!digest) event = new SparkEvent({ type, metadata, timestamp, digest });\n  else event = null;\n\n  if (invalidEvent || invalidParams || !event) {\n    throw new SparkEvent({\n      type: 'CREATE_EVENT_ERROR',\n      metadata: {\n        eventId: randomCuid()\n      },\n      timestamp,\n      data: { message: invalidEvent ? `Invalid event type: ${type}` : `Invalid event params: ${JSON.stringify(params)}` },\n    });\n  }\n\n  // TODO - settings for optional logging\n  const isError = event.type.endsWith(\"_ERROR\");\n  // if (isError) console.error(event);\n\n  return event;\n};\n","import { SparkRequestEvent, createEvent } from \"../events/SparkEvent\";\nimport { ConfirmEventType, ErrorEventType, RequestEventType } from \"../events/SparkEvent/types\";\n\nexport const ChannelErrorTypes = {\n  CHANNEL_INVALID_PEER_INFO_ERROR: 'CHANNEL_INVALID_PEER_INFO_ERROR',\n  CHANNEL_INVALID_MESSAGE_ERROR: 'CHANNEL_INVALID_MESSAGE_ERROR',\n  CHANNEL_RECEIPT_ERROR: 'CHANNEL_RECEIPT_ERROR',\n  CHANNEL_SEND_EVENT_ERROR: 'CHANNEL_UNEXPECTED_SEND_EVENT_ERROR',\n  CHANNEL_HANDLE_EVENT_ERROR: 'CHANNEL_UNEXPECTED_HANDLE_EVENT_ERROR',\n  CHANNEL_REQUEST_TIMEOUT_ERROR: 'CHANNEL_TIMEOUT_ERROR',\n  CHANNEL_UNEXPECTED_ERROR: 'CHANNEL_UNEXPECTED_ERROR',\n  CHANNEL_LOG_EVENT_ERROR: 'CHANNEL_LOG_EVENT_ERROR',\n  CHANNEL_CLOSED_ERROR: 'CHANNEL_CLOSED_ERROR',\n  CHANNEL_NO_STREAMS_AVAILABLE_ERROR: 'CHANNEL_NO_STREAMS_AVAILABLE_ERROR',\n} as const;\n\nexport const ChannelErrors = {\n  CHANNEL_INVALID_PEER_INFO_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_INVALID_PEER_INFO_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Missing peer info.' }\n  }),\n  CHANNEL_RECEIPT_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_RECEIPT_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Invalid receipt.' }\n  }),\n  CHANNEL_INVALID_MESSAGE_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_INVALID_MESSAGE_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Invalid message.' }\n  }),\n  CHANNEL_UNEXPECTED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_UNEXPECTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected channel error.' }\n  }),\n  CHANNEL_SEND_EVENT_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_SEND_EVENT_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected send event error.' }\n  }),\n  CHANNEL_LOG_EVENT_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_LOG_EVENT_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected log event error.' }\n  }),\n  CHANNEL_CLOSED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_CLOSED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Channel closed error.' }\n  }),\n  CHANNEL_REQUEST_TIMEOUT_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_REQUEST_TIMEOUT_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Channel timeout error.' }\n  }),\n  CHANNEL_REJECT_OPEN_REQUEST_ERROR: (request: SparkRequestEvent, message?: string) => createEvent({\n    type: 'OPEN_CONFIRM_ERROR',\n    metadata: { channelId: request.metadata.channelId, request: request.metadata },\n    data: { message: message || 'Channel rejected error.' }\n  }),\n  CHANNEL_NO_STREAMS_AVAILABLE_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: ChannelErrorTypes.CHANNEL_NO_STREAMS_AVAILABLE_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'No streams available.' }\n  }),\n}","import { Identifier } from \"../../controllers/SparkController/types\";\nimport { createEvent } from \"../../events/SparkEvent\";\nimport { EventId } from \"../../events/SparkEvent/types\";\nimport { PublicKeys } from \"../../spark/types\";\nimport { ChannelId, SignedEncryptedData, SignedReceipt } from \"./types\";\n\nexport const ChannelEventTypes = {\n  PING_REQUEST: 'PING_REQUEST',\n  PING_CONFIRM: 'PING_CONFIRM',\n  OPEN_REQUEST: 'OPEN_REQUEST',\n  OPEN_CONFIRM: 'OPEN_CONFIRM',\n  CLOSE_REQUEST: 'CLOSE_REQUEST',\n  CLOSE_CONFIRM: 'CLOSE_CONFIRM',\n  MESSAGE_REQUEST: 'MESSAGE_REQUEST',\n  MESSAGE_CONFIRM: 'MESSAGE_CONFIRM',\n  CALL_REQUEST: 'CALL_REQUEST',\n  CALL_CONFIRM: 'CALL_CONFIRM',\n  HANGUP_REQUEST: 'HANGUP_REQUEST',\n  HANGUP_CONFIRM: 'HANGUP_CONFIRM',\n} as const;\n\nexport type ReceiptTypes = {\n  OPEN_REQUEST: {\n    type: typeof ChannelEventTypes['OPEN_REQUEST'],\n    timestamp: number,\n    metadata: { eventId: EventId, channelId: ChannelId },\n    data: { peers: Identifier[] }\n  },\n  CLOSE_REQUEST: {\n    type: typeof ChannelEventTypes['CLOSE_REQUEST'],\n    timestamp: number,\n    metadata: { eventId: EventId, channelId: ChannelId },\n    data: { peers: Identifier[] }\n  },\n  MESSAGE_REQUEST: {\n    type: typeof ChannelEventTypes['MESSAGE_REQUEST'],\n    timestamp: number,\n    metadata: { eventId: EventId, channelId: ChannelId },\n    data: { message: string }\n  },\n  CALL_REQUEST: {\n    type: typeof ChannelEventTypes['CALL_REQUEST'],\n    timestamp: number,\n    metadata: { eventId: EventId, channelId: ChannelId },\n  },\n  HANGUP_REQUEST: {\n    type: typeof ChannelEventTypes['HANGUP_REQUEST'],\n    timestamp: number,\n    metadata: { eventId: EventId, channelId: ChannelId },\n  },\n}\n\nexport type DigestTypes = {\n  MESSAGE_REQUEST: {\n    message: string,\n  },\n  MESSAGE_CONFIRM: {\n    receipt: SignedReceipt<any, ReceiptTypes['MESSAGE_REQUEST']>\n  },\n}\n\nexport const ChannelEvents = {\n  PING_REQUEST: ({ metadata }: {\n    metadata: { channelId: ChannelId }\n  }) => createEvent({\n    type: ChannelEventTypes.PING_REQUEST,\n    metadata: { ...metadata },\n    data: {}\n  }),\n  PING_CONFIRM: ({ metadata }: {\n    metadata: { channelId: ChannelId }\n  }) => createEvent({\n    type: ChannelEventTypes.PING_CONFIRM,\n    metadata: { ...metadata },\n    data: {}\n  }),\n  OPEN_REQUEST: ({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: { identifier: Identifier, publicKeys: PublicKeys, [key: string]: any }\n  }) => createEvent({\n    type: ChannelEventTypes.OPEN_REQUEST,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  OPEN_CONFIRM: <Receipt>({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: {\n      identifier: Identifier,\n      publicKeys: PublicKeys,\n      receipt: SignedReceipt<Receipt, ReceiptTypes['OPEN_REQUEST']>\n      [key: string]: any\n    }\n  }) => createEvent({\n    type: ChannelEventTypes.OPEN_CONFIRM,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  CLOSE_REQUEST: ({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: Record<string, any>\n  }) => createEvent({\n    type: ChannelEventTypes.CLOSE_REQUEST,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  CLOSE_CONFIRM: <Receipt>({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: {\n      receipt: SignedReceipt<Receipt, ReceiptTypes['CLOSE_REQUEST']>\n      [key: string]: any\n    }\n  }) => createEvent({\n    type: ChannelEventTypes.CLOSE_CONFIRM,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  MESSAGE_REQUEST: <Digest>({ metadata, digest }: {\n    metadata: { channelId: ChannelId },\n    digest: SignedEncryptedData<Digest, DigestTypes['MESSAGE_REQUEST']>,\n  }) => createEvent({\n    type: ChannelEventTypes.MESSAGE_REQUEST,\n    metadata: { ...metadata },\n    digest,\n  }),\n  MESSAGE_CONFIRM: <Digest>({ metadata, digest }: {\n    metadata: { channelId: ChannelId },\n    digest: SignedEncryptedData<Digest, DigestTypes['MESSAGE_CONFIRM']>,\n  }) => createEvent({\n    type: ChannelEventTypes.MESSAGE_CONFIRM,\n    metadata: { ...metadata },\n    digest,\n  }),\n  CALL_REQUEST: ({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: {},\n  }) => createEvent({\n    type: ChannelEventTypes.CALL_REQUEST,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  CALL_CONFIRM: <Receipt>({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: {\n      receipt: SignedReceipt<Receipt, ReceiptTypes['CALL_REQUEST']>\n    }\n  }) => createEvent({\n    type: ChannelEventTypes.CALL_CONFIRM,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  HANGUP_REQUEST: ({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: {},\n  }) => createEvent({\n    type: ChannelEventTypes.HANGUP_REQUEST,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n  HANGUP_CONFIRM: <Receipt>({ metadata, data }: {\n    metadata: { channelId: ChannelId },\n    data: {\n      receipt: SignedReceipt<Receipt, ReceiptTypes['HANGUP_REQUEST']>\n    }\n  }) => createEvent({\n    type: ChannelEventTypes.HANGUP_CONFIRM,\n    metadata: { ...metadata },\n    data: { ...data }\n  }),\n}","import { SparkChannel } from \".\";\nimport { Identifier } from \"../../controllers/SparkController/types\";\nimport { SparkConfirmEvent, SparkEvent, SparkRequestEvent } from \"../../events/SparkEvent\";\nimport { EventType } from \"../../events/SparkEvent/types\";\nimport { Spark } from \"../../spark/Spark\";\nimport { PublicKeys } from \"../../spark/types\";\nimport { CamelCase } from \"../../utilities/types\";\n\nexport const ChannelTypes: {\n  [key: string]: ChannelType\n} = {\n  WebRTC: 'WebRTC',\n  HttpRest: 'HttpRest',\n  HttpFetch: 'HttpFetch',\n  PostMessage: 'PostMessage',\n} as const;\n\nexport type ChannelType = 'WebRTC' | 'HttpFetch' | 'HttpRest' | 'PostMessage';\nexport type ChannelId = string;\nexport type ChannelPeer = {\n  identifier?: Identifier,\n  publicKeys?: PublicKeys,\n  [key: string]: any,\n}\nexport type ChannelState = {\n  [key: string]: any,\n}\n\n// make channelevents equal to sparkeventinterface but with everything mandatory \nexport type ChannelLoggedEvent = {\n  event: SparkEvent, // the original event\n  request?: boolean, // set true if we sent the event\n  response?: boolean, // set true if we received the event\n}\n\nexport interface ChannelExport {\n  channelId: ChannelId,\n  type: ChannelType,\n  peer: ChannelPeer,\n  eventLog: ChannelLoggedEvent[],\n}\n\n// todo - use these to validate receipt and seal shapes\nexport type SignedReceipt<Shape, Expected> = Shape extends Expected ? string : never;\nexport type SignedEncryptedData<Shape, Expected> = Shape extends Expected ? string : never;\n\nexport type SparkChannelActions = ['OPEN', 'CLOSE', 'MESSAGE'];\nexport const SparkChannelActions = ['OPEN', 'CLOSE', 'MESSAGE'] as const;\n\nexport type RequestMethod<Action extends string> = Uncapitalize<CamelCase<Action>>;\nexport type OnRequestMethod<Action extends string> = `on${Capitalize<CamelCase<Action>>}Requested`;\n\ntype ConfirmMethod<Action extends string> = `confirm${Capitalize<CamelCase<Action>>}`;\nexport type OnConfirmMethod<Action extends string> = `on${Capitalize<CamelCase<Action>>}Confirmed`;\n\nexport type RequestParams = {\n  metadata?: Record<string, any>,\n  data?: Record<string, any>,\n}\n\nexport type RequestOptions = {\n  timeout?: number,\n  retries?: number,\n}\n\nexport type SparkChannelInterface<Actions extends string[]> = {\n  readonly channelId: ChannelId;\n  readonly type: ChannelType;\n  readonly peer: ChannelPeer;\n  readonly state: ChannelState;\n  readonly eventLog: ChannelLoggedEvent[];\n  readonly eventTypes: {\n    [key: string]: EventType\n  }\n\n  export(): ChannelExport,\n  import(params: ChannelExport): void,\n} & {\n    [key in RequestMethod<Actions[number]>]: (params: RequestParams, options?: RequestOptions) => Promise<any>;\n  } & {\n    [key in OnRequestMethod<Actions[number]>]: (event: SparkRequestEvent) => Promise<void>;\n  } & {\n    [key in ConfirmMethod<Actions[number]>]: (event: SparkRequestEvent) => Promise<void>;\n  } & {\n    [key in OnConfirmMethod<Actions[number]>]: (event: SparkConfirmEvent) => Promise<void>;\n  }\n\n  export type SparkChannelParams = {\n    spark: Spark<any, any, any, any, any>,\n    channelId?: ChannelId,\n    type?: ChannelType,\n    peer?: ChannelPeer,\n    state?: ChannelState,\n    eventLog?: ChannelLoggedEvent[],\n    actions?: string[],\n  }\n\n  export type ChannelReceive = (\n    callback: ({ event, confirmOpen, rejectOpen }: { event: SparkEvent, confirmOpen: () => Promise<SparkChannel>, rejectOpen: () => void }) => Promise<void>,\n    options: { spark: Spark<any, any, any, any, any>, [key: string]: any }\n  ) => void;"],"mappings":"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","names":["EventEmitter"]}