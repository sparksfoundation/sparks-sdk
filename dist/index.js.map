{"version":3,"sources":["../src/spark/Spark.ts"],"sourcesContent":["import { SparkAgentInterface } from \"../agents/SparkAgent/types\";\nimport { SparkCipherInterface } from \"../ciphers/SparkCipher/types\";\nimport { SparkControllerInterface } from \"../controllers/SparkController/types\";\nimport { SparkHasherInterface } from \"../hashers/SparkHasher/types\";\nimport { SparkSignerInterface } from \"../signers/SparkSigner/types\";\nimport { Constructable, UnwrapPromise } from \"../utilities/types\";\nimport { SignedEncryptedData, SparkInterface } from \"./types\";\n\nexport class Spark<\n  Agents extends SparkAgentInterface[],\n  Cipher extends SparkCipherInterface,\n  Controller extends SparkControllerInterface,\n  Hasher extends SparkHasherInterface,\n  Signer extends SparkSignerInterface,\n> implements SparkInterface<Agents, Cipher, Controller, Hasher, Signer> {\n\n  readonly agents: { [key: string]: Agents[number] };\n  readonly cipher: Cipher;\n  readonly controller: Controller;\n  readonly hasher: Hasher;\n  readonly signer: Signer;\n\n  constructor({ agents, cipher, controller, hasher, signer }: {\n    agents?: Constructable<Agents[number]>[],\n    cipher: Constructable<Cipher>,\n    controller: Constructable<Controller>,\n    hasher: Constructable<Hasher>,\n    signer: Constructable<Signer>,\n  }) {\n    this.agents = {};\n    this.cipher = new cipher(this);\n    this.hasher = new hasher(this);\n    this.signer = new signer(this);\n    this.controller = new controller(this);\n\n    if (agents && Array.isArray(agents) && agents.length > 0) {\n      agents.forEach((agent) => {\n        const _agent = new agent(this) as InstanceType<Constructable<Agents[number]>>;\n        const name = agent.name.charAt(0).toLowerCase() + agent.name.slice(1);\n        this.agents[name] = _agent;\n      });\n    }\n\n    Object.defineProperties(this, {\n      agents: { enumerable: false, writable: false },\n      cipher: { enumerable: false, writable: false },\n      hasher: { enumerable: false, writable: false },\n      signer: { enumerable: false, writable: false },\n      controller: { enumerable: false, writable: false },\n    });\n  }\n\n  get identifier(): Controller['identifier'] {\n    return this.controller.identifier;\n  }\n\n  get publicKeys(): {\n    cipher: Cipher['publicKey'],\n    signer: Signer['publicKey'],\n  } {\n    return {\n      cipher: this.cipher.publicKey,\n      signer: this.signer.publicKey,\n    };\n  }\n\n  get secretKeys(): {\n    cipher: Cipher['secretKey'],\n    signer: Signer['secretKey'],\n  } {\n    return {\n      cipher: this.cipher.secretKey,\n      signer: this.signer.secretKey,\n    };\n  }\n\n  get keyPairs(): {\n    signer: Signer['keyPair'],\n    cipher: Cipher['keyPair'],\n  } {\n    return {\n      signer: this.signer.keyPair,\n      cipher: this.cipher.keyPair,\n    };\n  }\n\n  get keyEventLog(): Controller['keyEventLog'] {\n    return this.controller.keyEventLog;\n  }\n\n  // generateKeyPairs can be called with either same or separate params for both or cipher and signer\n  private _generateKeyPairs: {\n    (params: Parameters<Cipher['generateKeyPair']>[0] & Parameters<Signer['generateKeyPair']>[0]): Promise<{\n      cipher: UnwrapPromise<ReturnType<Cipher['generateKeyPair']>>,\n      signer: UnwrapPromise<ReturnType<Signer['generateKeyPair']>>\n    }>;\n    (params: { cipher: Parameters<Cipher['generateKeyPair']>[0], signer: Parameters<Signer['generateKeyPair']>[0] }): Promise<{\n      cipher: UnwrapPromise<ReturnType<Cipher['generateKeyPair']>>,\n      signer: UnwrapPromise<ReturnType<Signer['generateKeyPair']>>\n    }>;\n    (): Promise<{\n      cipher: UnwrapPromise<ReturnType<Cipher['generateKeyPair']>>,\n      signer: UnwrapPromise<ReturnType<Signer['generateKeyPair']>>\n    }>;\n  } = async (params?: any) => {\n    const signerParams = params && params.signer ? params.signer : params;\n    const cipherParams = params && params.cipher ? params.cipher : params;\n    const signer = await this.signer.generateKeyPair(signerParams) as UnwrapPromise<ReturnType<Signer['generateKeyPair']>>;\n    const cipher = await this.cipher.generateKeyPair(cipherParams) as UnwrapPromise<ReturnType<Cipher['generateKeyPair']>>;\n    return Promise.resolve({ signer, cipher });\n  };\n\n  // sets the key pairs for both cipher and signer\n  private _setKeyPairs = async (params: {\n    cipher: Parameters<Cipher['setKeyPair']>[0],\n    signer: Parameters<Signer['setKeyPair']>[0]\n  }) => {\n    const { cipher, signer } = params;\n    this.signer.setKeyPair(signer);\n    this.cipher.setKeyPair(cipher);\n  }\n\n  // public facing properties and interface methods\n  public import: {\n    (params: Parameters<Cipher['generateKeyPair']>[0] & Parameters<Signer['generateKeyPair']>[0] & { data: SignedEncryptedData }): Promise<void>;\n    (params: { cipher: Parameters<Cipher['generateKeyPair']>[0], signer: Parameters<Signer['generateKeyPair']>[0], data: SignedEncryptedData }): Promise<void>;\n  } = async (params?: any) => {\n    const { data, ...keyPairParams } = params;\n    const keyPairs = await this._generateKeyPairs(keyPairParams);\n    this._setKeyPairs(keyPairs);\n\n    const opened = await this.signer.open({ signature: data, publicKey: this.publicKeys.signer });\n    const decrypted = await this.cipher.decrypt({ data: opened }) as Record<string, any>;\n\n    await Promise.all(\n      Object.entries(this.agents).map(async ([key, agent]) => {\n\n        await agent.import(decrypted.agents[key]);\n      })\n    );\n\n    await Promise.all([\n      this.cipher.import(decrypted.cipher),\n      this.hasher.import(decrypted.hasher),\n      this.signer.import(decrypted.signer),\n      this.controller.import(decrypted.controller),\n    ]);\n  }\n\n  public export: SparkInterface<Agents, Cipher, Controller, Hasher, Signer>['export'] = async () => {\n    const data: {\n      agents: Record<string, any>,\n      channels: Record<string, any>[],\n    } = {\n      agents: {},\n      channels: [],\n    };\n\n    await Promise.all(\n      Object.entries(this.agents).map(async ([key, agent]) => {\n        data.agents[key] = await agent.export();\n      })\n    );\n\n    Object.assign(data, {\n      cipher: await this.cipher.export(),\n      hasher: await this.hasher.export(),\n      signer: await this.signer.export(),\n      controller: await this.controller.export(),\n    });\n\n    const encrypted = await this.cipher.encrypt({ data });\n    const signed = await this.signer.seal({ data: encrypted });\n    return signed;\n  }\n\n  public incept: {\n    (params: Parameters<Cipher['generateKeyPair']>[0] & Parameters<Signer['generateKeyPair']>[0]): Promise<void>;\n    (params: { cipher: Parameters<Cipher['generateKeyPair']>[0], signer: Parameters<Signer['generateKeyPair']>[0] }): Promise<void>;\n    (): Promise<void>;\n  } = async (params?: any) => {\n    const keyPairs = await this._generateKeyPairs(params);\n    this._setKeyPairs(keyPairs);\n    await this.controller.incept();\n  };\n\n  public rotate: {\n    (params: Parameters<Cipher['generateKeyPair']>[0] & Parameters<Signer['generateKeyPair']>[0]): Promise<void>;\n    (params: { cipher: Parameters<Cipher['generateKeyPair']>[0], signer: Parameters<Signer['generateKeyPair']>[0] }): Promise<void>;\n  } = async (params) => {\n    const nextKeyPairs = await this._generateKeyPairs(params);\n    await this.controller.rotate({ nextKeyPairs });\n    this._setKeyPairs(nextKeyPairs);\n  }\n\n  public destroy: SparkInterface<Agents, Cipher, Controller, Hasher, Signer>['destroy'] = async (params) => {\n    await this.controller.destroy();\n  }\n\n  // cipher facade\n  get generateCipherSharedKey(): Cipher['generateSharedKey'] {\n    return this.cipher.generateSharedKey;\n  }\n\n  get encrypt(): Cipher['encrypt'] {\n    return this.cipher.encrypt;\n  }\n\n  get decrypt(): Cipher['decrypt'] {\n    return this.cipher.decrypt;\n  }\n\n  // hasher facade\n  get hash(): Hasher['hash'] {\n    return this.hasher.hash;\n  }\n\n  // signer facade\n  get sign(): Signer['sign'] {\n    return this.signer.sign;\n  }\n\n  get seal(): Signer['seal'] {\n    return this.signer.seal;\n  }\n\n  get verify(): Signer['verify'] {\n    return this.signer.verify;\n  }\n\n  get open(): Signer['open'] {\n    return this.signer.open;\n  }\n}\n"],"mappings":"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","names":[]}