{"version":3,"sources":["../../../src/signers/Ed25519/index.ts","../../../src/utilities/index.ts","../../../src/events/SparkEvent/index.ts","../../../src/errors/signers.ts","../../../src/signers/SparkSigner/index.ts"],"sourcesContent":["import { SparkSigner } from \"../SparkSigner\";\nimport nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { SigatureDetached, Signature, SignatureData, SignatureVerified, SignerKeyPair, SignerPublicKey, SignerSecretKey } from \"../SparkSigner/types\";\nimport { parseJSON } from \"../../utilities\";\nimport { SignerErrors } from \"../../errors/signers\";\nimport { SparkEvent } from \"../../events/SparkEvent\";\n\nexport class Ed25519 extends SparkSigner {\n  constructor() {\n    super({\n      algorithm: 'ed25519',\n    });\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    await super.import(data);\n    return Promise.resolve();\n  }\n  \n  public async export(): Promise<Record<string, any>> {\n    const data = await super.export();\n    return Promise.resolve(data);\n  }\n\n  public async generateKeyPair(params?: { secretKey?: SignerSecretKey }): Promise<SignerKeyPair> {\n    try {\n      const keyPair = params?.secretKey ? nacl.sign.keyPair.fromSecretKey(util.decodeBase64(params?.secretKey)) : nacl.sign.keyPair();\n      const publicKey = util.encodeBase64(keyPair.publicKey);\n      const secretKey = util.encodeBase64(keyPair.secretKey);\n      if (!publicKey || !secretKey) throw SignerErrors.SIGNER_KEYPAIR_ERROR();\n      return { publicKey, secretKey };\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(SignerErrors.SIGNER_UNEXPECTED_ERROR({\n        message: `Failed to generate key pair. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async seal({ data }: { data: SignatureData }): Promise<Signature> {\n    try {\n      const dataString = typeof data === 'string' ? data : JSON.stringify(data);\n      const uintData = util.decodeUTF8(dataString as string);\n      const uintSecretKey = util.decodeBase64(this._secretKey);\n      const signature = util.encodeBase64(nacl.sign(uintData, uintSecretKey));\n      if (!signature) throw SignerErrors.SIGNER_SEAL_ERROR();\n      return signature;\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(SignerErrors.SIGNER_UNEXPECTED_ERROR({\n        message: `Failed to seal data. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async open({ publicKey, signature }: { publicKey: SignerPublicKey, signature: Signature }): Promise<SignatureData> {\n    try {\n      const uintSignature = util.decodeBase64(signature);\n      const uintPublicKey = util.decodeBase64(publicKey);\n      const uintResult = nacl.sign.open(uintSignature, uintPublicKey);\n      if (!uintResult) throw SignerErrors.SIGNER_OPEN_SEAL_ERROR();\n      const utf8Result = util.encodeUTF8(uintResult);\n      const data = parseJSON(utf8Result) || utf8Result;\n      if (!data) throw SignerErrors.SIGNER_OPEN_SEAL_ERROR();\n      return data;\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(SignerErrors.SIGNER_UNEXPECTED_ERROR({\n        message: `Failed to open data. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async sign({ data }: { data: SignatureData }): Promise<SigatureDetached> {\n    try {\n      const dataString = typeof data === 'string' ? data : JSON.stringify(data);\n      const uintData = util.decodeUTF8(dataString as string);\n      const uintSecretKey = util.decodeBase64(this._secretKey);\n      const signature = util.encodeBase64(nacl.sign.detached(uintData, uintSecretKey));\n      if (!signature) throw SignerErrors.SIGNER_SIGNING_ERROR();\n      return signature;\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(SignerErrors.SIGNER_UNEXPECTED_ERROR({\n        message: `Failed to sign data. ${error?.message || ''}`,\n      }));\n    }\n  }\n\n  public async verify({ publicKey, signature, data }: { publicKey: SignerPublicKey, signature: Signature, data: SignatureData }): Promise<SignatureVerified> {\n    try {\n      if (!data) throw new Error('Missing data to verify signature.');\n      const dataString = typeof data === 'string' ? data : JSON.stringify(data);\n      const uintData = util.decodeUTF8(dataString as string);\n      const uintSignature = util.decodeBase64(signature);\n      const uintPublicKey = util.decodeBase64(publicKey);\n      const verified = nacl.sign.detached.verify(uintData, uintSignature, uintPublicKey);\n      return verified;\n    } catch (error: any) {\n      if (error instanceof SparkEvent) return Promise.reject(error);\n      return Promise.reject(SignerErrors.SIGNER_UNEXPECTED_ERROR({\n        message: `Failed to verify signature. ${error?.message || ''}`,\n      }));\n    }\n  }\n}\n","import nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { createId, isCuid } from '@paralleldrive/cuid2';\n\n/**\n * @returns a timestamp in milliseconds since epoch in terms of UTC\n */\nexport function utcEpochTimestamp() {\n  const now = new Date()\n  return now.getTime() + now.getTimezoneOffset() * 60 * 1000;\n}\n\n/**\n * @returns a parsed json string or null if it fails\n */\nexport function parseJSON(data: string) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n}\n\n/**\n * @returns a new unique salt\n */\nexport function randomSalt(len: number = 32) {\n  return util.encodeBase64(nacl.randomBytes(len));\n}\n\n/**\n * @returns a new unique identifier\n */\nexport function randomCuid() {\n  return createId();\n}\n\n/**\n * @returns whether the identifier is a valid CUID\n */\nexport function validCuid(id: string) {\n  return isCuid(id);\n}\n\n/**\n * SNAKE_CASE to PascalCase\n * @returns a PascalCase string\n */\nexport function snakeToPascal(str: string) {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, char) => char.toUpperCase()).replace(/^[a-z]/, char => char.toUpperCase());\n}","import { randomCuid, utcEpochTimestamp } from \"../../utilities\";\nimport { ConfirmEventType, CreateEventFunction, CreateEventParams, ErrorEventType, RequestEventType, SparkEventInterface, SparkEventParams } from \"./types\";\n\n\nexport class SparkEvent implements SparkEventInterface {\n  readonly type:  RequestEventType | ConfirmEventType | ErrorEventType;\n  readonly timestamp: number;\n  readonly metadata: Record<string, any>;\n  readonly data: Record<string, any>;\n  readonly digest: string;\n\n  constructor(args: SparkEventParams) {\n    this.type = args.type;\n    this.metadata = args.metadata;\n    this.timestamp = args.timestamp;\n    if (args.data) this.data = args.data;\n    if (args.digest) this.digest = args.digest;\n  }\n}\n\nexport class SparkRequestEvent extends SparkEvent {\n  declare readonly type: RequestEventType;\n}\nexport class SparkConfirmEvent extends SparkEvent {\n  declare readonly type: ConfirmEventType;\n}\nexport class SparkErrorEvent extends SparkEvent {\n  declare readonly type: ErrorEventType;\n}\n\nexport const createEvent: CreateEventFunction = (params: CreateEventParams): any => {\n  const { type, data, digest } = params;\n  const timestamp: number = utcEpochTimestamp();\n  const metadata = { ...(params.metadata || {}), eventId: randomCuid() };\n\n  const invalidEvent = (!type.endsWith(\"_REQUEST\") && !type.endsWith(\"_CONFIRM\") && !type.endsWith(\"_ERROR\"));\n  const invalidParams = !!((data && digest) || (!data && !digest));\n\n  let event;\n  if (!!data) event = new SparkEvent({ type, metadata, timestamp, data });\n  else if (!!digest) event = new SparkEvent({ type, metadata, timestamp, digest });\n  else event = null;\n\n  if (invalidEvent || invalidParams || !event) {\n    throw new SparkEvent({\n      type: 'CREATE_EVENT_ERROR',\n      metadata: {\n        eventId: randomCuid()\n      },\n      timestamp,\n      data: { message: invalidEvent ? `Invalid event type: ${type}` : `Invalid event params: ${JSON.stringify(params)}` },\n    });\n  }\n\n  // TODO - settings for optional logging\n  const isError = event.type.endsWith(\"_ERROR\");\n  // if (isError) console.error(event);\n\n  return event;\n};\n","import { createEvent } from \"../events/SparkEvent\";\n\nexport const SignerErrorTypes = {\n  SIGNER_PUBLICKEY_ERROR: 'SIGNER_PUBLICKEY_ERROR',\n  SIGNER_SECRETKEY_ERROR: 'SIGNER_SECRETKEY_ERROR',\n  SIGNER_KEYPAIR_ERROR: 'SIGNER_KEYPAIR_ERROR',\n  SIGNER_SEAL_ERROR: 'SIGNER_SEAL_ERROR',\n  SIGNER_SIGNATURE_ERROR: 'SIGNER_SIGNATURE_ERROR',\n  SIGNER_SIGNING_ERROR: 'SIGNER_SIGNING_ERROR',\n  SIGNER_VERIFY_SIGNATURE_ERROR: 'SIGNER_VERIFY_SIGNATURE_ERROR',\n  SIGNER_OPEN_SEAL_ERROR: 'SIGNER_OPEN_SEAL_ERROR',\n  SIGNER_INVALID_SALT_ERROR: 'SIGNER_INVALID_SALT_ERROR',\n  SIGNER_UNEXPECTED_ERROR: 'SIGNER_UNEXPECTED_ERROR',\n} as const;\n\nexport const SignerErrors = {\n  SIGNER_PUBLICKEY_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_PUBLICKEY_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate public key.' }\n  }),\n  SIGNER_SECRETKEY_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_SECRETKEY_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate secret key.' }\n  }),\n  SIGNER_KEYPAIR_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_KEYPAIR_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to generate key pair.' }\n  }),\n  SIGNER_SEAL_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_SEAL_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to seal data.' }\n  }),\n  SIGNER_SIGNATURE_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_SIGNATURE_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Invalid signature.' }\n  }),\n  SIGNER_SIGNING_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_SIGNING_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to sign data.' }\n  }),\n  SIGNER_INVALID_SALT_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_INVALID_SALT_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Missing password salt.' }\n  }),\n  SIGNER_OPEN_SEAL_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_OPEN_SEAL_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to open seal.' }\n  }),\n  SIGNER_VERIFY_SIGNATURE_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_VERIFY_SIGNATURE_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to verify signature.' }\n  }),\n  SIGNER_UNEXPECTED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: SignerErrorTypes.SIGNER_UNEXPECTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected signer error.' }\n  }),\n}\n\n","import { SignerErrors } from \"../../errors/signers\";\nimport { Signature, SignatureData, SignatureVerified, SignerKeyPair, SignerPublicKey, SignerSecretKey, SparkSignerInterface } from \"./types\";\n\nexport abstract class SparkSigner implements SparkSignerInterface {\n  public readonly algorithm: string;\n  protected _publicKey: SignerPublicKey;\n  protected _secretKey: SignerSecretKey;\n\n  constructor({ algorithm }: { algorithm: string }) {\n    this.algorithm = algorithm;\n    this.setKeyPair = this.setKeyPair.bind(this);\n    this.generateKeyPair = this.generateKeyPair.bind(this);\n    this.sign = this.sign.bind(this);\n    this.verify = this.verify.bind(this);\n    this.seal = this.seal.bind(this);\n    this.open = this.open.bind(this);\n  }\n\n  public get publicKey(): SignerPublicKey {\n    return this._publicKey;\n  }\n\n  public get secretKey(): SignerSecretKey {\n    return this._secretKey;\n  }\n\n  public get keyPair(): SignerKeyPair {\n    return {\n      publicKey: this.publicKey,\n      secretKey: this.secretKey,\n    }\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    return Promise.resolve();\n  }\n\n  public async export(): Promise<Record<string, any>> {\n    return Promise.resolve({});\n  }\n\n  public setKeyPair({ publicKey, secretKey }: SignerKeyPair): void {\n    try {\n      if (!publicKey) throw SignerErrors.SIGNER_PUBLICKEY_ERROR();\n      if (!secretKey) throw SignerErrors.SIGNER_SECRETKEY_ERROR();\n      this._publicKey = publicKey as SignerPublicKey;\n      this._secretKey = secretKey as SignerSecretKey;\n    } catch (error: any) {\n      if (error instanceof Error) throw error;\n      throw SignerErrors.SIGNER_UNEXPECTED_ERROR({\n        message: `Failed to set key pair. ${error?.message || ''}`,\n      });\n    }\n  }\n\n  public abstract generateKeyPair(params?: Record<string, any>): Promise<SignerKeyPair>;\n  public abstract sign(params?: Record<string, any>): Promise<Signature>;\n  public abstract verify(params?: Record<string, any>): Promise<SignatureVerified>;\n\n  public abstract seal(params?: Record<string, any>): Promise<Signature>;\n  public abstract open(params?: Record<string, any>): Promise<SignatureData>;\n}"],"mappings":"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","names":["import_tweetnacl","import_tweetnacl_util","nacl","util"]}