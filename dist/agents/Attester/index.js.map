{"version":3,"sources":["../../../src/utilities/index.ts","../../../src/events/SparkEvent/index.ts","../../../src/errors/spark.ts","../../../src/agents/SparkAgent/index.ts","../../../src/agents/Attester/index.ts"],"sourcesContent":["import nacl from \"tweetnacl\";\nimport util from \"tweetnacl-util\";\nimport { createId, isCuid } from '@paralleldrive/cuid2';\n\n/**\n * @returns a timestamp in milliseconds since epoch in terms of UTC\n */\nexport function utcEpochTimestamp() {\n  const now = new Date()\n  return now.getTime() + now.getTimezoneOffset() * 60 * 1000;\n}\n\n/**\n * @returns a parsed json string or null if it fails\n */\nexport function parseJSON(data: string) {\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n}\n\n/**\n * @returns a new unique salt\n */\nexport function randomSalt(len: number = 32) {\n  return util.encodeBase64(nacl.randomBytes(len));\n}\n\n/**\n * @returns a new unique identifier\n */\nexport function randomCuid() {\n  return createId();\n}\n\n/**\n * @returns whether the identifier is a valid CUID\n */\nexport function validCuid(id: string) {\n  return isCuid(id);\n}\n\n/**\n * SNAKE_CASE to PascalCase\n * @returns a PascalCase string\n */\nexport function snakeToPascal(str: string) {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, char) => char.toUpperCase()).replace(/^[a-z]/, char => char.toUpperCase());\n}","import { randomCuid, utcEpochTimestamp } from \"../../utilities\";\nimport { ConfirmEventType, CreateEventFunction, CreateEventParams, ErrorEventType, RequestEventType, SparkEventInterface, SparkEventParams } from \"./types\";\n\n\nexport class SparkEvent implements SparkEventInterface {\n  readonly type:  RequestEventType | ConfirmEventType | ErrorEventType;\n  readonly timestamp: number;\n  readonly metadata: Record<string, any>;\n  readonly data: Record<string, any>;\n  readonly digest: string;\n\n  constructor(args: SparkEventParams) {\n    this.type = args.type;\n    this.metadata = args.metadata;\n    this.timestamp = args.timestamp;\n    if (args.data) this.data = args.data;\n    if (args.digest) this.digest = args.digest;\n  }\n}\n\nexport class SparkRequestEvent extends SparkEvent {\n  declare readonly type: RequestEventType;\n}\nexport class SparkConfirmEvent extends SparkEvent {\n  declare readonly type: ConfirmEventType;\n}\nexport class SparkErrorEvent extends SparkEvent {\n  declare readonly type: ErrorEventType;\n}\n\nexport const createEvent: CreateEventFunction = (params: CreateEventParams): any => {\n  const { type, data, digest } = params;\n  const timestamp: number = utcEpochTimestamp();\n  const metadata = { ...(params.metadata || {}), eventId: randomCuid() };\n\n  const invalidEvent = (!type.endsWith(\"_REQUEST\") && !type.endsWith(\"_CONFIRM\") && !type.endsWith(\"_ERROR\"));\n  const invalidParams = !!((data && digest) || (!data && !digest));\n\n  let event;\n  if (!!data) event = new SparkEvent({ type, metadata, timestamp, data });\n  else if (!!digest) event = new SparkEvent({ type, metadata, timestamp, digest });\n  else event = null;\n\n  if (invalidEvent || invalidParams || !event) {\n    throw new SparkEvent({\n      type: 'CREATE_EVENT_ERROR',\n      metadata: {\n        eventId: randomCuid()\n      },\n      timestamp,\n      data: { message: invalidEvent ? `Invalid event type: ${type}` : `Invalid event params: ${JSON.stringify(params)}` },\n    });\n  }\n\n  // TODO - settings for optional logging\n  const isError = event.type.endsWith(\"_ERROR\");\n  // if (isError) console.error(event);\n\n  return event;\n};\n","import { createEvent } from \"../events/SparkEvent\";\n\nexport const SparkErrorTypes = {\n  SPARK_IMPORT_ERROR: 'SPARK_IMPORT_ERROR',\n  SPARK_EXPORT_ERROR: 'SPARK_EXPORT_ERROR',\n  SPARK_UNEXPECTED_ERROR: 'SPARK_UNEXPECTED_ERROR',\n} as const;\n\nexport const SparkErrors = {\n  SPARK_IMPORT_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SparkErrorTypes.SPARK_IMPORT_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to import data.' }\n  }),\n  SPARK_EXPORT_ERROR: ({ metadata = {} }: { metadata?: Record<string, any> } = {}) => createEvent({\n    type: SparkErrorTypes.SPARK_EXPORT_ERROR,\n    metadata: { ...metadata },\n    data: { message: 'Failed to export data.' }\n  }),\n  SPARK_UNEXPECTED_ERROR: ({ metadata = {}, message }: { metadata?: Record<string, any>, message?: string } = {}) => createEvent({\n    type: SparkErrorTypes.SPARK_UNEXPECTED_ERROR,\n    metadata: { ...metadata },\n    data: { message: message || 'Unexpected spark error.' }\n  }),\n}\n\n","import { SparkErrors } from \"../../errors\";\nimport { SparkInterface } from \"../../spark/types\";\nimport { SparkAgentInterface } from \"./types\";\n\nexport abstract class SparkAgent implements SparkAgentInterface {\n  protected _spark: SparkInterface<any, any, any, any, any>;\n  \n  constructor(spark: SparkInterface<any, any, any, any, any>) {\n    this._spark = spark;\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    if (!data) throw SparkErrors.SPARK_IMPORT_ERROR();\n    return Promise.resolve();\n  }\n  \n  public async export(): Promise<Record<string, any>> {\n    return Promise.resolve({});\n  }\n}","import { SparkErrors } from \"../../errors/spark\";\nimport { SparkAgent } from \"../SparkAgent\";\nimport Ajv from \"ajv\"\nimport { MerkleTree } from \"merkletreejs\";\n\nexport class Attester extends SparkAgent {\n\n  constructor(spark: any) {\n    super(spark);\n    this.buildCredential = this.buildCredential.bind(this);\n    this.hash = this.hash.bind(this);\n  }\n\n  private hash(data: string) {\n    return this._spark.hasher.hash({ data });\n  }\n\n  private getLeafHashes(data: Record<string, any>) {\n    return Object.keys(data).flatMap((key) => {\n      // if it's an array, hash each element\n      if (Array.isArray(data[key])) {\n        return data[key].map((element: any) => {\n          return typeof element === \"object\" ? JSON.stringify(element) : element.toString();\n        }).map(this.hash);\n      }\n      const value = typeof data[key] === \"object\" ? JSON.stringify(data[key]) : data[key].toString();\n      return this.hash(value);\n    })\n  }\n\n  private async getMerkleAttributeProofs(tree: MerkleTree, leaves: string[], data: Record<string, any>) {\n    const proofs = Object.keys(data).flatMap((attributeKey, index) => {\n      if (Array.isArray(data[attributeKey])) {\n        return data[attributeKey].map((element: any, childIndex: number) => {\n          const proofIndex = index + childIndex;\n          const proof = tree.getProof(leaves[proofIndex], proofIndex);\n          return {\n            attribute: `${attributeKey}.${childIndex}`,\n            proof: proof.map((node) => node.data.toString('hex')),\n          };\n        });\n      }\n\n      const proof = tree.getProof(leaves[index], index);\n      return {\n        attribute: attributeKey,\n        proof: proof.map((node) => node.data.toString('hex')),\n      };\n    })\n\n    return {\n      \"merkleRoot\": tree.getHexRoot(),\n      \"attributes\": proofs,\n    }\n  }\n\n  public async buildCredential({ schema, data }: { schema: Record<string, any>, data: Record<string, any> }) {\n\n    const ajv = new Ajv(); // Create an instance of Ajv\n    const validate = ajv.compile(schema.properties.credentialSubject); // Compile the schema\n    const isValid = validate(data);\n\n    if (!isValid) {\n      console.log(validate.errors);\n      return null;\n    }\n\n    const verifiableCredential = {\n      \"@context\": [\n        \"https://www.w3.org/2018/credentials/v1\",\n        \"https://sparks.foundation/credentials/ethereum/schema\"\n      ],\n      \"id\": schema[\"id\"],\n      \"type\": [\"VerifiableCredential\", schema[\"name\"].replace(\" \", \"\")],\n      \"issuer\": this._spark.identifier,\n      \"issuanceDate\": new Date().toISOString(),\n      \"credentialSubject\": {\n        ...data,\n      }\n    } as any;\n\n    const leaves = this.getLeafHashes(data);\n    const merkleTree = new MerkleTree(leaves, this.hash);\n    const merkle = await this.getMerkleAttributeProofs(merkleTree, leaves, data);\n\n    const proofs = [\n      {\n        \"type\": \"DataIntegrityProof\",\n        \"created\": new Date().toISOString(),\n        \"verificationMethod\": this._spark.identifier,\n        \"signatureValue\": await this._spark.signer.seal({ data: verifiableCredential }),\n      },\n      {\n        \"type\": \"MerkleProof\",\n        \"signatureAlgorithm\": this._spark.signer.algorithm,\n        \"digestAlgorithm\": this._spark.hasher.algorithm,\n        \"signatureValue\": await this._spark.signer.seal({ data: merkle }),\n      }\n    ]\n\n    // Include the Merkle root and proofs in the Verifiable Credential\n    verifiableCredential.proofs = proofs;\n\n    return verifiableCredential;\n  }\n\n  public async import(data: Record<string, any>): Promise<void> {\n    return Promise.resolve();\n  }\n\n  public async export(): Promise<Record<string, any>> {\n    return Promise.resolve({});\n  }\n}\n"],"mappings":"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","names":["proof"]}